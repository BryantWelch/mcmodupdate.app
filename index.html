<!-- This Source Code Form is subject to the terms of the Mozilla Public
     License, v. 2.0. If a copy of the MPL was not distributed with this
     file, You can obtain one at https://mozilla.org/MPL/2.0/. -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MC Mod Updater | Update Your Minecraft Mods</title>
    <meta name="description" content="Easily update your Minecraft mods or build a new modpack from scratch. Upload your .jar files or search for mods on Modrinth to find the latest compatible versions and dependencies.">
    <meta name="keywords" content="Minecraft, Mod, Updater, Modpack, Builder, Modrinth, Fabric, Forge, NeoForge, Quilt, Update, Minecraft Mods">
    <meta name="author" content="Bryant Welch">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="googlebot" content="index, follow">
    <meta name="google-site-verification" content="d-Z4KwHExUTAtvp9VwSdNKAgimNP8hglF61av3rrC1E">
    <meta name="google-adsense-account" content="ca-pub-1728229586138721">
    <link rel="canonical" href="https://mcmodupdate.app/">
    
    <!-- Favicon and Theme Configuration -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="site.webmanifest">
    <meta name="msapplication-TileColor" content="#6366f1">
    <meta name="theme-color" content="#11101d">

    <!-- Open Graph / Social Media Tags -->
    <meta property="og:title" content="MC Updater | Update & Build Minecraft Modpacks">
    <meta property="og:description" content="A powerful web tool to update existing mods and discover new ones via the Modrinth API.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mcmodupdate.app/">
    <meta property="og:image" content="https://mcmodupdate.app/social-preview.png">

    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="MC Mod Updater | Update Your Minecraft Mods">
    <meta name="twitter:description" content="Easily update your Minecraft mods or build a new modpack from scratch. Upload your .jar files or search for mods on Modrinth.">
    <meta name="twitter:image" content="https://mcmodupdate.app/social-preview.png">

    <!-- Rybbit Analytics -->
    <script
        src="https://app.rybbit.io/api/script.js"
        data-site-id="1392"
        defer
    ></script>

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "MC Mod Updater",
      "description": "Easily update your Minecraft mods or build a new modpack from scratch. Upload your .jar files or search for mods on Modrinth to find the latest compatible versions and dependencies.",
      "url": "https://mcmodupdate.app/",
      "applicationCategory": "UtilitiesApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Person",
        "name": "Bryant Welch"
      },
      "keywords": "Minecraft, Mod, Updater, Modpack, Builder, Modrinth, Fabric, Forge, NeoForge, Quilt",
      "inLanguage": "en-US",
      "browserRequirements": "Requires JavaScript",
      "softwareVersion": "1.0"
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://unpkg.com/toml-js@0.0.8/lib/amd/toml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <style>
      
      /* -- CSS -- */
      :root {
        --bg-color: #11101d;
        --card-bg: #1e1e2f;
        --primary-text: #e0e0e0;
        --secondary-text: #a0a0a0;
        --border-color: #4a4a5e;
        --dropzone-bg: rgba(255, 255, 255, 0.05);
        --dropzone-hover-bg: rgba(255, 255, 255, 0.1);
        --pill-bg: #2a2a3a;
        --gradient-start: #a855f7;
        --gradient-end: #6366f1;
        --success-color: #4caf50;
        --error-color: #f44336;
        --warning-color: #ffc107;
        --alpha-color: #ef5350;
        --beta-color: #ff9800;
      }
      html,
      body {
        width: 100%;
        overflow-x: hidden;
      }
      body {
        background-color: var(--bg-color);
        color: var(--primary-text);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
        padding: 2rem 0 0 0;
        box-sizing: border-box;
      }
      .main-container {
        width: 100%;
        max-width: 800px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.5rem;
        flex-grow: 1;
        padding: 0 1rem;
      }
      h1 {
        font-size: 3rem;
        margin-bottom: 0.5rem;
        font-weight: bold;
        background: linear-gradient(
          to right,
          var(--gradient-start),
          var(--gradient-end)
        );
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        margin: 0;
      }
      .subtitle {
        color: var(--secondary-text);
        margin-top: 0;
      }
      .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1.5rem;
      }
      select {
        background-color: var(--bg-color);
        color: var(--primary-text);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.5rem 1rem;
        font-size: 1rem;
        transition: background-color 0.2s ease, border-color 0.2s ease;
      }
      select:hover {
        border-color: var(--gradient-start);
      }
      .dropzone {
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        max-width: 400px;
        height: 150px;
        margin-left: auto;
        margin-right: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        transition: all 0.3s ease;
        background-color: var(--dropzone-bg);
        cursor: pointer;
        overflow: hidden;
      }
      .dropzone.dropzone-expanded {
        max-width: 100%;
        min-height: 120px;
        height: auto;
      }
      .dropzone:hover,
      .dropzone.dragover {
        background-color: var(--dropzone-hover-bg);
        border-color: var(--gradient-start);
      }
      .dropzone-prompt {
        color: var(--secondary-text);
      }
      .file-list {
        display: flex;
        gap: 0.75rem;
        width: 100%;
        overflow-x: auto;
        padding-bottom: 1.5rem;
        scrollbar-width: auto;
        scrollbar-color: var(--border-color) rgba(255, 255, 255, 0.03);
      }
      .file-list::-webkit-scrollbar {
        height: 12px;
      }
      .file-list::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 4px;
      }
      .file-list::-webkit-scrollbar-thumb {
        background-color: var(--border-color);
        border-radius: 4px;
      }
      .file-list::-webkit-scrollbar-thumb:hover {
        background-color: var(--gradient-start);
      }
      .file-pill {
        background-color: var(--pill-bg);
        padding: 0.5rem 1rem;
        padding-right: 28px;
        border-radius: 1rem;
        white-space: nowrap;
        font-size: 0.9rem;
        position: relative;
        display: inline-flex;
        align-items: center;
        border: 1px solid transparent;
        transition: border-color 0.2s ease;
        cursor: pointer;
      }
      .file-pill:hover {
        border-color: var(--gradient-start);
      }
      .file-pill span {
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
      }
      .file-pill-remove {
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        cursor: pointer;
        font-size: 1.4rem;
        line-height: 1;
        color: var(--secondary-text);
      }
      .file-pill-remove:hover {
        color: var(--primary-text);
      }
      .update-button {
        background: linear-gradient(
          to right,
          var(--gradient-start),
          var(--gradient-end)
        );
        color: white;
        border: none;
        border-radius: 8px;
        padding: 0.6rem 0.5rem;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        transition: transform 0.15s ease;
        max-width: 160px;
      }
      .update-button:hover {
        transform: scale(1.05);
      }
      .update-button:disabled {
        background: var(--border-color);
        cursor: not-allowed;
        transform: none;
      }

      .action-buttons-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
      }

      .clear-all-button {
        background-color: transparent;
        color: var(--secondary-text);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.6rem 1.2rem;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        display: none; /* Hidden by default */
      }

      .clear-all-button:hover {
        background-color: var(--pill-bg);
        color: var(--primary-text);
        border-color: var(--primary-text);
      }

      #scroll-buttons-container {
        position: fixed;
        bottom: 4.5rem;
        right: 2rem;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .scroll-btn {
        width: 48px;
        height: 48px;
        background-color: var(--card-bg);
        color: var(--primary-text);
        border: 1px solid var(--border-color);
        border-radius: 50%;
        cursor: pointer;
        display: none; /* Hidden by default */
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        opacity: 0.7;
      }

      .scroll-btn:hover {
        opacity: 1;
        transform: scale(1.1);
        background-color: var(--gradient-start);
        border-color: var(--gradient-start);
      }
      .info-button {
        position: absolute;
        top: 0;
        right: 0;
        width: 60px;
        height: 60px;
        background: var(--gradient-end);
        border: none;
        padding: 0;
        cursor: pointer;
        clip-path: polygon(0% 0%, 100% 0%, 100% 100%);
        border-radius: 0;
      }
      .info-button svg {
        position: absolute;
        top: 8px;
        right: 8px;
        stroke: white;
      }
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.3s ease-in-out;
        opacity: 0; /* Start transparent */
        pointer-events: none; /* Prevent interaction when hidden */
      }
      #search-modal {
        align-items: flex-start; /* Aligns content to the top */
        justify-content: center; /* Center horizontally */
        padding-top: 0; /* Remove the viewport-based padding */
      }
      
      #search-modal .modal-content {
        position: absolute;
        top: 280px; /* Position directly below the controls - adjust this value as needed */
        max-width: 800px; /* Match the main container width */
        width: calc(100% - 2rem); /* Account for some margin */
        margin: 0 1rem; /* Side margins */
      }
      .modal-overlay.visible {
        opacity: 1; /* Fade in to full opacity */
        pointer-events: auto; /* Allow interaction when visible */
      }
      .modal-content {
        background-color: #1e1e2f;
        padding: 2rem;
        border-radius: 12px;
        max-width: 600px;
        width: 90%;
        position: relative;
        color: var(--secondary-text);
        transform: scale(0.95);
        transition: transform 0.3s ease-in-out;
      }
      .modal-overlay.visible .modal-content {
        transform: scale(1);
      }
      .modal-actions {
        text-align: center;
        margin-top: 1rem;
      }
      .modal-close-button {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        font-size: 2rem;
        color: var(--secondary-text);
        cursor: pointer;
        line-height: 1;
      }
      .modal-close-button:hover {
        color: var(--primary-text);
      }
      #alert-icon {
        display: inline-block;
        margin-right: 0.75rem;
        vertical-align: middle;
      }
      footer {
        width: 100%;
        background-color: #0c0c17;
        color: var(--secondary-text);
        padding: 0rem 0 0.5rem 0;
        font-size: 0.9rem;
        margin-top: 3rem;
      }
      .footer-content {
        display: flex;
        justify-content: space-around;
        flex-wrap: wrap;
        gap: 1rem;
        max-width: 900px;
        margin: 0 auto 1rem auto;
        padding: 0 1rem;
        text-align: left;
      }
      .footer-column h4 {
        color: var(--primary-text);
        font-size: 1.5rem;
        margin-bottom: 1rem;
        font-weight: 600;
      }
      .footer-column ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .footer-column ul li {
        margin-bottom: 0.6rem;
      }
      .footer-column ul li a {
        color: var(--secondary-text);
        text-decoration: none;
        transition: color 0.2s ease;
      }
      .footer-column ul li a:hover {
        color: var(--primary-text);
        text-decoration: underline;
      }
      .footer-bottom {
        text-align: center;
        padding: 1.2rem 1rem 0.6rem;
        border-top: 1px solid var(--border-color);
        font-size: 0.85rem;
        position: relative;
      }
      .footer-bottom p {
        margin: 0;
      }
      .footer-bottom p a {
        color: var(--secondary-text);
        text-decoration: underline;
        transition: color 0.2s ease;
      }
      .footer-bottom p a:hover {
        color: var(--primary-text);
      }
      .kofi-button {
        position: absolute;
        right: 1rem;
        top: 55%;
        margin-top: -18px;
        transition: transform 0.15s ease;
      }
      .kofi-button:hover {
        transform: scale(1.05);
      }
      .kofi-button img {
        height: 36px;
        width: auto;
        border-radius: 6px;
      }
      .progress-bar-container {
        width: 100%;
        background-color: var(--card-bg);
        border-radius: 4px;
        margin-top: 1rem;
        display: none; /* Hidden by default */
      }
      .progress-bar {
        width: 0%;
        height: 10px;
        background: linear-gradient(
          to right,
          var(--gradient-start),
          var(--gradient-end)
        );
        border-radius: 4px;
        transition: width 0.3s ease-out;
      }
      .status-message {
        color: var(--secondary-text);
        font-size: 0.9rem;
        margin: 0; /* Margin will be part of the transition */
        max-height: 0; /* Start with zero height */
        opacity: 0; /* Start fully transparent */
        overflow: hidden; /* Important for the max-height trick */
        transition: all 0.2s ease-in-out; /* Animate everything */
      }
      .status-message.visible {
        margin-top: 0.5rem; /* Add margin when visible */
        max-height: 6em; /* Increased to accommodate more lines of text */
        opacity: 1; /* Animate to be fully visible */
      }
      #results-area {
        width: 100%;
        margin-top: 1rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }
      .results-section {
        display: none; /* Hidden by default */
      }
      .results-section.visible {
        display: block;
      }
      .results-section h2 {
        text-align: left;
        color: var(--primary-text);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
      }
      .results-list {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .result-card {
        background-color: var(--card-bg);
        border-radius: 8px;
        padding: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        text-align: left;
      }
      .result-card-main {
        display: flex;
        gap: 1rem;
        width: 100%;
      }
      .result-card.failure,
      .result-card.warning {
        align-items: center;
      }
      .result-card.failure {
        border-left: 4px solid var(--error-color);
      }
      .result-card.warning {
        border-left: 4px solid var(--warning-color);
      }
      .result-card.success {
        border-left: 4px solid var(--success-color);
      }
      .result-card.dependency {
        border-left: 4px solid #3b82f6; /* Blue color for dependencies */
      }
      .result-card.already-up-to-date {
        border-left: 4px solid #ffffff; /* White color for already up-to-date */
      }
      .mod-icon-link {
        flex-shrink: 0;
      }
      .mod-icon {
        width: 64px;
        height: 64px;
        border-radius: 8px;
        object-fit: cover;
        background-color: var(--bg-color);
      }
      .mod-details {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 0;
      }
      .mod-title {
        font-size: 1.2rem;
        font-weight: bold;
        color: var(--primary-text);
      }
      .mod-title a {
        color: inherit;
        text-decoration: none;
      }
      .mod-title a:hover {
        text-decoration: underline;
      }
      .mod-author {
        font-size: 0.9rem;
        font-weight: normal;
        color: var(--secondary-text);
      }
      .mod-author a {
        color: var(--secondary-text);
        text-decoration: none;
      }
      .mod-author a:hover {
        text-decoration: underline;
      }
      .mod-description {
        font-size: 0.9rem;
        color: var(--secondary-text);
        margin-top: 0.25rem;
      }
      .mod-meta {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 1rem;
        font-size: 0.85rem;
        color: var(--secondary-text);
        margin-top: 0.5rem;
      }
      .mod-meta-item {
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }
      /* --- Category Tooltip Styles --- */
      .category-tooltip-container {
        position: relative; /* This is crucial for positioning the tooltip */
        display: flex;
        align-items: center;
      }

      .category-tooltip {
        visibility: hidden; /* Hide the tooltip by default */
        opacity: 0;
        transition: opacity 0.2s ease;

        position: absolute;
        bottom: 125%; /* Position it above the icon */
        left: 50%;
        transform: translateX(-50%); /* Center it horizontally */

        background-color: var(--card-bg);
        color: var(--primary-text);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.5rem 0.75rem;
        z-index: 10;

        white-space: nowrap; /* Keep the tooltip on a single line */
        font-size: 0.85rem;
      }

      /* Show the tooltip when hovering over the container */
      .category-tooltip-container:hover .category-tooltip {
        visibility: visible;
        opacity: 1;
      }

      /* --- Meta Data Tooltip Styles (Environment, Downloads, etc.) --- */
      .meta-tooltip-container {
        position: relative;
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }

      .meta-tooltip {
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease;

        position: absolute;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);

        background-color: var(--card-bg);
        color: var(--primary-text);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.5rem 0.75rem;
        z-index: 10;

        white-space: nowrap;
        font-size: 0.85rem;
      }

      .meta-tooltip-container:hover .meta-tooltip {
        visibility: visible;
        opacity: 1;
      }
      .changelog-toggle {
        cursor: pointer;
        text-decoration: underline;
      }
      .changelog-toggle:hover {
        color: var(--primary-text);
      }
      /* Override hover color change for reason toggle in warning cards */
      .warning .changelog-toggle:hover {
        color: var(--warning-color); /* Keep the same warning color on hover */
      }
      .mod-channel-links {
        display: flex;
        align-items: center;
      }

      .channel-link {
        text-decoration: underline;
        cursor: pointer;
        transition: color 0.2s ease;
      }

      /* Match the hover effect of the changelog link */
      .channel-link:hover {
        color: var(--primary-text);
      }

      /* Set the specific text colors for each channel */
      .channel-link.release {
        color: var(--success-color);
      }
      .channel-link.beta {
        color: var(--beta-color);
      }
      .channel-link.alpha {
        color: var(--alpha-color);
      }
      .changelog-content {
        display: none;
        width: 100%;
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-color);
        color: var(--secondary-text);
        font-size: 0.9rem;
      }
      .changelog-content.visible {
        display: block;
      }
      .changelog-content ul {
        padding-left: 20px;
        margin: 0;
      }
      .changelog-content video,
      .changelog-content img {
        max-width: 100%;
        height: auto;
        border-radius: 8px; /* Optional: adds rounded corners to the media */
      }
      .mod-actions {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 1rem;
        flex-shrink: 0;
      }
      .version-select {
        background-color: var(--pill-bg);
        border: 1px solid var(--border-color);
        color: var(--primary-text);
        border-radius: 6px;
        padding: 0.3rem 0.5rem;
        width: clamp(100px, 25vw, 140px);
        white-space: nowrap; /* Prevents the text inside from wrapping */
        overflow: hidden; /* Hides the text that overflows the container */
        text-overflow: ellipsis; /* Adds the "..." for any hidden text */
      }
      .version-type {
        font-weight: bold;
        margin-left: 0.5em;
      }
      .version-type-release {
        color: var(--success-color);
      }
      .version-type-beta {
        color: var(--beta-color);
      }
      .version-type-alpha {
        color: var(--alpha-color);
      }
      .download-link {
        background-color: var(--success-color);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        text-decoration: none;
        font-weight: bold;
        font-size: 0.9rem;
      }

      /* Ignore Mode Styles */
      .header-button.ignore-mode-active {
        background: var(--gradient-start);
        color: white;
      }
      
      .download-link.ignore-mode {
        background-color: var(--error-color);
        color: white;
      }
      
      .download-link.ignore-mode.ignored {
        background-color: #2196F3; /* Blue for un-ignore */
        color: white;
      }
      
      .download-link.ignored-state {
        background-color: var(--border-color);
        color: var(--secondary-text);
        cursor: not-allowed;
      }
      
      .result-card.ignored {
        opacity: 0.4;
        filter: grayscale(50%);
      }


      .results-actions {
        display: flex;
        justify-content: center;
        align-items: flex-start; /* Aligns the tops of the buttons */
        gap: 1rem;
        margin-top: 1rem;
      }
      .action-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.6rem 1.2rem;
        background: linear-gradient(
          to right,
          var(--gradient-start),
          var(--gradient-end)
        );
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1rem;
        transition: transform 0.15s ease;
      }
      .action-button:hover {
        transform: scale(1.05);
      }
      .search-container {
        position: relative;
        display: flex;
        align-items: center;
      }
      .search-container input {
        background-color: var(--bg-color);
        color: var(--primary-text);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 0.5rem 1rem;
        padding-right: 2.5rem;
        font-size: 1rem;
        transition: border-color 0.2s ease, color 0.2s ease;
        margin-left: 0.3rem;
      }
      .search-container input:hover {
        background-color: var(--pill-bg);
      }
      .search-container input:focus {
        outline: none;
        border-color: var(--gradient-start);
        color: var(--primary-text);
      }
      .search-clear-button {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: var(--secondary-text);
        font-size: 1.4rem;
        cursor: pointer;
        display: none; /* Hidden by default */
        padding: 4px;
        line-height: 1;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
      }
      
      .search-clear-button.show {
        display: flex;
      }
      .search-clear-button:hover {
        color: var(--primary-text);
      }

      #search-results-container {
        margin-top: 1.5rem;
        max-height: 60vh;
        overflow-y: auto;
        padding-right: 0.5rem; /* For scrollbar spacing */
      }

      /* Style for the "Add" button on search result cards */
      .add-mod-button {
        background-color: var(--success-color);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        text-decoration: none;
        font-weight: bold;
        font-size: 0.9rem;
        border: none;
        cursor: pointer;
      }
      .add-mod-button:disabled {
        background-color: var(--border-color);
        cursor: not-allowed;
      }

      /* Specific styling for the search modal load more button */
      #load-more-btn {
        width: 95% !important; /* Slightly smaller to accommodate hover scale effect */
        margin: 1rem auto 0 auto !important; /* Center the button */
        display: block !important; /* Ensure block display for margin auto to work */
      }

/* -- Styles for the header and the toggle button's container -- */
.results-header-container {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 0.5rem;
  margin-bottom: 1rem;
}

.results-header-container h2 {
  border-bottom: none;
  padding-bottom: 0;
  margin-bottom: 0;
}

.header-buttons {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

/* -- Styles for search boxes in results sections -- */
.search-box {
  background-color: var(--bg-color);
  color: var(--primary-text);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 0.4rem 0.8rem;
  font-size: 0.9rem;
  width: 200px;
  transition: border-color 0.2s ease, background-color 0.2s ease;
}

.search-box:hover {
  background-color: var(--pill-bg);
}

.search-box:focus {
  outline: none;
  border-color: var(--gradient-start);
  background-color: var(--bg-color);
}

.search-box::placeholder {
  color: var(--secondary-text);
}

/* -- Styles for sort dropdown -- */
.sort-dropdown-container {
  position: relative;
  display: inline-block;
}

.sort-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  min-width: 150px;
  display: none;
  overflow: visible;
}

.sort-dropdown.show {
  display: block;
}

.sort-option {
  padding: 0.75rem 1rem;
  cursor: pointer;
  color: var(--primary-text);
  font-size: 0.9rem;
  transition: background-color 0.2s ease;
  border: none;
  background: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.sort-option:first-child {
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
}

.sort-option:last-child {
  border-bottom-left-radius: 12px;
  border-bottom-right-radius: 12px;
}

.sort-option:hover {
  background-color: var(--dropzone-hover-bg);
  border-color: var(--gradient-start);
}

.sort-option.active {
  background-color: var(--gradient-start);
  color: white;
}

.sort-option.has-submenu {
  position: relative;
}

.sort-submenu {
  position: absolute;
  left: 100%;
  top: 0;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  min-width: 140px;
  display: none;
  overflow: hidden;
  z-index: 1001;
}

.sort-option.has-submenu:hover .sort-submenu {
  display: block;
}

.sort-submenu .sort-option {
  padding: 0.75rem 1rem;
  font-size: 0.9rem;
}

.sort-submenu .sort-option:first-child {
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
}

.sort-submenu .sort-option:last-child {
  border-bottom-left-radius: 12px;
  border-bottom-right-radius: 12px;
}

.submenu-arrow {
  font-size: 0.6em;
  color: var(--secondary-text);
  transition: color 0.2s ease;
  flex-shrink: 0;
}

.sort-option.has-submenu:hover .submenu-arrow {
  color: var(--primary-text);
}

/* -- Styles for the layout toggle button itself -- */
.layout-toggle {
  background: transparent;
  border: 1px solid var(--border-color);
  color: var(--secondary-text);
  border-radius: 6px;
  cursor: pointer;
  padding: 0.3rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.layout-toggle:hover {
  color: var(--primary-text);
  border-color: var(--primary-text);
  background-color: var(--pill-bg);
}

/* -- Default Visibility: Hide grid-only elements -- */
.grid-view-channels {
  display: none;
}

/* -- Grid View Container Style -- */
.results-list.grid-view {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1rem;
}

/* -- Card Styles in Grid View -- */
.results-list.grid-view .result-card {
  flex-direction: column;
  padding: 0.75rem;
  align-items: center;
  text-align: center;
  gap: 0.5rem;
}

.results-list.grid-view .result-card-main {
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}

/* -- Child Element Styles in Grid View -- */
.results-list.grid-view .mod-icon {
  width: 64px;
  height: 64px;
}

.results-list.grid-view .mod-title {
  font-size: 1rem;
  font-weight: 600;
  line-height: 1.3;
  height: auto;
  min-height: 2.6em;
  text-align: center;
}

/* In grid view, make title link and chain icon inline, tags on new line */
.results-list.grid-view .mod-title > a,
.results-list.grid-view .mod-title > .dependency-chain-tooltip-container {
  display: inline;
}

/* Hide elements not needed in compact view */
.results-list.grid-view .mod-author,
.results-list.grid-view .mod-description,
.results-list.grid-view .mod-meta {
  display: none;
}

/* -- Action Area in Grid View -- */
.results-list.grid-view .mod-actions {
  width: 100%;
  margin-top: auto;
  padding-top: 0.5rem;
  border-top: 1px solid var(--border-color);
  align-items: stretch;
  gap: 0.5rem;
}

.results-list.grid-view .version-select {
  text-align: center;
  padding: 0.2rem 0.5rem;
  margin-left: auto;
  margin-right: auto;
}

/* -- New Bottom Line Container -- */
.results-list.grid-view .grid-bottom-line {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.85rem;
}

.results-list.grid-view .grid-view-channels {
  display: block;
}

.results-list.grid-view .download-link {
  background: none;
  padding: 0;
  font-weight: normal;
  color: var(--secondary-text);
  text-decoration: underline;
}

.results-list.grid-view .download-link:hover {
  color: var(--primary-text);
}

/* Tags styling in grid view - make them appear on new line */
.results-list.grid-view .mod-title-tag,
.results-list.grid-view .dependency-tooltip-container {
  display: block;
  margin-left: 0; /* Remove left margin since they're on their own line */
  margin-top: 0.25rem;
  text-align: center;
}



/* This new class will style ALL tags */
.mod-title-tag {
  font-size: 0.9rem;
  font-weight: normal;
  color: var(--secondary-text); /* Matches the author text color */
  margin-left: 0.5rem;
  font-style: italic;
  white-space: nowrap; /* Prevents the tag itself from breaking onto two lines */
}

/* Dependency tag specific styling - same pattern as category tooltip */
.dependency-tooltip-container {
  position: relative;
  display: inline-flex;
  align-items: center;
}

.dependency-tag {
  /* Use the same styling as the base mod-title-tag */
  font-size: 0.9rem;
  font-weight: normal;
  color: var(--secondary-text);
  margin-left: 0.5rem;
  font-style: italic;
  white-space: nowrap;
  cursor: help;
}



.dependency-tooltip {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s ease;
  
  position: absolute;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  
  background-color: var(--card-bg);
  color: var(--primary-text);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 0.5rem 0.75rem;
  z-index: 10;
  
  white-space: nowrap;
  font-size: 0.85rem;
}

.dependency-tooltip-container:hover .dependency-tooltip {
  visibility: visible;
  opacity: 1;
}

/* Dependency chain icon and tooltip styling */
.dependency-chain-tooltip-container {
  position: relative;
  display: inline-flex;
  align-items: center;
  margin-left: 0.5rem;
}

.dependency-chain-icon {
  color: var(--secondary-text);
  cursor: help;
  transition: color 0.2s ease;
}

.dependency-chain-icon:hover {
  color: var(--primary-text);
}

.dependency-chain-tooltip {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s ease;
  
  position: absolute;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  
  background-color: var(--card-bg);
  color: var(--primary-text);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 0.5rem 0.75rem;
  z-index: 10;
  
  white-space: nowrap;
  font-size: 0.85rem;
  text-align: center;
}

.dependency-chain-tooltip-container:hover .dependency-chain-tooltip {
  visibility: visible;
  opacity: 1;
}

/* Cache indicator styling */
.cache-indicator-container {
  position: relative;
  display: inline-flex;
  align-items: center;
  margin-left: 0.5rem;
}

.cache-icon {
  color: var(--secondary-text);
  cursor: help;
  transition: color 0.2s ease;
}

.cache-icon:hover {
  color: var(--primary-text);
}

.cache-tooltip {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s ease;
  
  position: absolute;
  bottom: 125%;
  left: 50%;
  transform: translateX(-50%);
  
  background-color: var(--card-bg);
  color: var(--primary-text);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 0.5rem 0.75rem;
  z-index: 10;
  
  white-space: nowrap;
  font-size: 0.85rem;
  text-align: center;
}

.cache-indicator-container:hover .cache-tooltip {
  visibility: visible;
  opacity: 1;
}

  /* --- Begin Mobile Responsive Styles --- */
  @media (max-width: 700px) {
    /* Make the main container use the full width */
    .main-container {
      padding: 0 1rem;
    }
    
    /* Make search boxes smaller on mobile */
    .search-box {
      width: 150px;
    }
    
    /* Adjust sort dropdown on mobile */
    .sort-dropdown {
      right: 0;
      left: auto;
      min-width: 180px;
    }
    
    /* Reduce header size */
    h1 {
      font-size: 2.2rem;
    }

    /* --- 1. Stack the main controls vertically --- */
    .controls {
      flex-direction: column;
      align-items: stretch; /* Make all control groups full-width */
      gap: 1rem;
    }

    .control-group {
      display: flex;
      flex-direction: column; /* Stack label above the input/select */
      align-items: flex-start;
      gap: 0.25rem;
    }

    /* Make inputs and selects full-width */
    .search-container input,
    .control-group select {
      width: 100%;
      box-sizing: border-box;
    }

    /* Make Update/Clear buttons full width */
    .action-buttons-container {
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 400px;
      gap: 1rem; /* Add a gap for nice spacing when both buttons are visible */
    }

    /* Center the welcome message content */
    #welcome-message h2,
    #welcome-message p {
      text-align: center;
    }

    /* --- Stack the result card content --- */
    .result-card-main {
      flex-direction: column;
      align-items: center; /* Center the icon */
      gap: 0.5rem;
    }

    .mod-details,
    .mod-actions {
      width: 100%; /* Allow details and actions to take full width */
      align-items: center; /* Makes dropdown/button full width */
    }

    .mod-details {
      text-align: center; /* Center the text below the icon */
    }

    .mod-meta {
      justify-content: center; /* Center the metadata items */
      margin-top: 1rem;
    }

    /* --- Fix the Footer Layout --- */
    .footer-content {
      flex-direction: column; /* Stack the columns vertically */
      text-align: center; /* Center the text inside each column */
      gap: 2rem; /* Add more space between the stacked sections */
    }

    .footer-bottom {
      display: flex;
      flex-direction: column; /* Stack the copyright and Ko-fi button */
      align-items: center;
      gap: 1rem;
      padding-top: 1.5rem;
    }

    .kofi-button {
      position: static; /* Remove absolute positioning */
      transform: none; /* Reset the transform */
      margin-top: 0.5rem; /* Add some space above it */
    }

    /* --- Mobile-friendly Info Modal --- */
    .modal-content {
      width: 95%;
      max-width: none;
      margin: 1rem;
      padding: 1.5rem;
      max-height: 85vh;
      overflow-y: auto;
    }

    .modal-content h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }

    .modal-content h3 {
      font-size: 1.2rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
    }

    .modal-content ul {
      padding-left: 1.25rem;
    }

    .modal-content li {
      margin-bottom: 0.5rem;
      line-height: 1.4;
    }

    /* --- Mobile Section Headers Layout --- */
    .results-header-container {
      flex-direction: column;
      align-items: stretch;
      gap: 1rem;
    }

    .results-header-container h2 {
      text-align: center;
      margin-bottom: 0;
    }

    .header-buttons {
      justify-content: center;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .search-box {
      width: 120px;
    }

    /* --- Mobile-specific search clear button positioning --- */
    .search-clear-button {
      right: 0.5rem !important;
      top: calc(50% + 12px) !important;
      font-size: 1.4rem;
      width: 32px;
      height: 32px;
      padding: 0;
      line-height: 1;
    }

    /* --- Mobile search modal positioning --- */
    #search-modal .modal-content {
      width: 95% !important;
      max-width: none !important;
      margin: 1rem !important;
      padding: 1.5rem !important;
      max-height: 85vh !important;
      overflow-y: auto !important;
      position: relative !important;
      top: auto !important;
      bottom: auto !important;
      left: auto !important;
      right: auto !important;
      border-radius: 12px !important;
    }
    
    /* --- Mobile search header layout --- */
    .modal-search-header .search-container {
      max-width: none !important;
    }
    
    /* Position the search modal overlay differently on mobile */
    #search-modal {
      align-items: center !important;
      justify-content: center !important;
      padding-top: 0 !important;
    }

    /* --- Mobile dropzone adjustments --- */
    body #dropzone.dropzone {
      width: 90% !important;
      max-width: 350px !important;
      margin: 0 auto !important;
      left: auto !important;
      right: auto !important;
      box-sizing: border-box !important;
    }
    
    body #dropzone.dropzone.dropzone-expanded {
      width: 90% !important;
      max-width: 90vw !important;
      margin: 0 auto !important;
      box-sizing: border-box !important;
    }

    /* --- Mobile welcome message adjustments --- */
    body #welcome-message {
      padding: 0 1rem !important;
      box-sizing: border-box !important;
    }

    /* --- Mobile result cards adjustments --- */
    body .result-card {
      margin: 0 1rem 1rem 1rem !important;
      box-sizing: border-box !important;
    }

    /* --- Mobile mod actions layout - side by side --- */
    body .mod-actions {
      flex-direction: row !important;
      justify-content: space-between !important;
      align-items: center !important;
      gap: 0.75rem !important;
    }
    
    body .mod-actions select {
      flex: 1 !important;
      min-width: 0 !important;
    }
    
    body .mod-actions .download-btn {
      flex-shrink: 0 !important;
      white-space: nowrap !important;
    }

    /* --- Mobile download buttons container --- */
    body .results-actions {
      flex-direction: column !important;
      gap: 0.75rem !important;
      align-items: center !important;
      margin: 0 1rem !important;
    }
    
    body .download-button-group {
      width: 100% !important;
      max-width: 300px !important;
    }
    
    body .download-button-group button {
      width: 100% !important;
      font-size: 0.9rem !important;
    }

    /* --- Mobile grid view layout adjustments --- */
    body .results-list.grid-view .mod-actions {
      flex-direction: column !important;
      gap: 0.5rem !important;
    }
    
    body .results-list.grid-view .version-select {
      width: 100% !important;
      margin: 0 !important;
      text-align: left !important;
    }
    
    body .results-list.grid-view .grid-bottom-line {
      flex-direction: row !important;
      justify-content: space-between !important;
      align-items: center !important;
      gap: 1rem !important;
      padding: 0 0.25rem !important;
    }

    /* Center the 'Add' button in the search modal on mobile */
    #search-modal .result-card .mod-actions {
      justify-content: center !important; /* Override the more generic rule */
      padding-top: 0.5rem;
    }

    /* Vertically align the clear button in the modal's search input on mobile */
    #modal-search-clear-button {
      top: 50% !important;
      transform: translateY(-50%) !important;
    }
  }
  /* --- End of Mobile Responsive Styles --- */

/* --- Download Button Styles --- */
  .download-button-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem; /* Creates a small space between the button and the text below it */
}

  .download-size-info {
    font-size: 0.7rem;
    margin-top: 0.15rem;
    color: var(--secondary-text);
}

/* --- Info Button Styles --- */
#info-button {
  /* Make the button larger without changing its shape */
  transform: scale(1.25);
  transform-origin: top right; /* Ensures scaling happens from the corner */
}

/* --- End of CSS */

/* Beginning of HTML */
    </style>
  </head>
  <body>
    <button id="info-button" class="info-button" aria-label="Show info">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="16" x2="12" y2="12"></line>
        <line x1="12" y1="8" x2="12.01" y2="8"></line>
      </svg>
    </button>
    <div class="main-container">
      <header>
        <h1>Minecraft Mod Updater</h1>
        <p class="subtitle">
          Easily find updates for your Minecraft Mods using the Modrinth API
        </p>
      </header>
      <div class="controls">
        <div class="control-group">
          <label for="mod-loader">Loader:</label>
          <select id="mod-loader" autocomplete="off">
            <option value="fabric">Fabric</option>
            <option value="forge">Forge</option>
            <option value="neoforge">NeoForge</option>
            <option value="quilt">Quilt</option>
          </select>
        </div>
        <div class="control-group">
          <label for="mc-version">Version:</label>
          <select id="mc-version"></select>
        </div>
        <div class="control-group search-container">
          <label for="mod-search">Search:</label>
          <input type="text" id="mod-search" placeholder="Find mods by name...">
          <button id="search-clear-button" class="search-clear-button">&times;</button>
        </div>
      </div>
      <div id="dropzone" class="dropzone">
        <div id="file-list-container" class="file-list"></div>
        <p id="dropzone-prompt" class="dropzone-prompt">
          Upload your mod files (.jar),
          <br />
          resource packs/shaders (.zip),
          <br />
          modpacks (.mrpack),
          <br />
          or 
          <br />
          use the search
        </p>
      </div>
      <div class="action-buttons-container">
        <button id="update-button" class="update-button">
          Update
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
        </button>
        <button id="clear-all-button" class="clear-all-button">
          Clear Input
        </button>
        <button
          id="clear-results-button"
          class="clear-all-button"
          style="display: none"
        >
          Clear Results
        </button>
      </div>
      <div id="progress-bar-container" class="progress-bar-container">
        <div id="progress-bar" class="progress-bar"></div>
      </div>
      <p id="status-message" class="status-message"></p>
      <div id="results-area">
        <div id="welcome-message" class="results-section visible">
          <h2 style="text-align: center">
            Welcome to the Minecraft Mod Updater &amp; Builder!
          </h2>
          <p style="text-align: left; line-height: 1.6">
            This tool is your one-stop shop for managing your Minecraft mods. You can
            easily find updates for your entire mod list, discover new mods, and
            export a ready-to-use modpack for your favorite launcher.
          </p>
          <h3 style="text-align: center; margin-top: 2rem">Ready to Start?</h3>
          <p style="text-align: left; line-height: 1.6">
            To get started, you can upload an entire modpack (<code>.mrpack</code>), individual mods (<code>.jar</code>), resource packs/shaders (<code>.zip</code>), or use the search bar to find new content. Then, click the "Update" button to see the magic happen!
          </p>
          <p
            style="
              text-align: left;
              font-style: italic;
              margin-top: 2rem;
              font-size: 0.9rem;
              color: var(--secondary-text);
            "
          >
            For more detailed instructions, click the info icon in the top-right
            corner.
          </p>
        </div>
      </div>
    </div>
    <input type="file" id="file-input" multiple style="display: none" accept=".jar,.mrpack,.zip" />

    <!-- Info Modal -->
    <div id="info-modal" class="modal-overlay">
      <div class="modal-content">
        <button id="modal-close-button" class="modal-close-button">&times;</button>
        
        <h2>MC Mod Updater &amp; Builder</h2>
        <p>
          This tool helps you update your existing Minecraft mods or build a brand new mod list from scratch. It uses the Modrinth API to find the latest compatible versions and can export your list as a standard Modrinth modpack. Note: This tool only searches Modrinth - mods from CurseForge or other sources won't be found. Dependencies are automatically detected and added to ensure your modpack works properly.
        </p>
        
        <h3>How to Use:</h3>
        <ul>
          <li><b>Loader / Version:</b> Select your desired mod loader (Fabric, Forge, NeoForge, Quilt) and target Minecraft version.</li>
          <li><b>Upload Files:</b> Drop a <code>.mrpack</code> file to load a modpack, or drag and drop your local <code>.jar</code> (mods) and <code>.zip</code> (resource packs, shaders) files into the upload area.</li>
          <li><b>Search for New Mods:</b> Use the search bar to find and add mods directly from Modrinth.</li>
          <li><b>Process Your List:</b> Click "Update" to find the latest compatible versions and dependencies.</li>
        </ul>

        <h3>Understanding Results:</h3>
        <p><b>Color-Coded Borders:</b></p>
        <ul>
          <li><b style="color: #4caf50;">Green border:</b> Successfully found updates for these mods</li>
          <li><b style="color: #3b82f6;">Blue border:</b> Dependencies automatically added to ensure compatibility</li>
          <li><b style="color: #ffffff;">White border:</b> Mods already up-to-date with the latest version</li>
          <li><b style="color: #ffc107;">Yellow border:</b> No compatible version found for your selected loader/version</li>
          <li><b style="color: #f44336;">Red border:</b> Mod not found on Modrinth or file could not be processed</li>
        </ul>

        <h3>Features &amp; Tools:</h3>
        <ul>
          <li><b>Search &amp; Filter:</b> Use the search boxes to quickly find specific mods in your results</li>
          <li><b>Sort Options:</b> Click the sort button to organize by name, downloads, followers, or filter by environment/channel</li>
          <li><b>Layout Toggle:</b> Switch between detailed list view and compact grid view using the layout button</li>
          <li><b>Copy Lists:</b> Use the copy button to quickly copy mod names to your clipboard</li>
          <li><b>Version Selection:</b> Choose between Release, Beta, or Alpha versions for each mod</li>
          <li><b>Download Options:</b> Download individual mods or get everything as a ready-to-use <code>.mrpack</code> file</li>
        </ul>

        <h3>Attributions:</h3>
        <p>
          This tool relies on the Modrinth API for all mod data. Please be aware of their ratelimits. The ratelimit is currently 300 requests per minute. The application will automatically pause and resume to respect these limits.
        </p>
      </div>
    </div>

    <!-- ALERT MODAL BLOCK -->
    <div id="alert-modal" class="modal-overlay">
      <div class="modal-content">
        <h2 id="alert-title"><span id="alert-icon"></span>Notice</h2>
        <p id="alert-message" style="margin: 1.5rem 0;"></p>
        <div class="modal-actions">
          <button id="alert-ok-button" class="action-button">OK</button>
        </div>
      </div>
    </div>

    <!-- SEARCH MODAL BLOCK -->
    <div id="search-modal" class="modal-overlay">
      <div class="modal-content">
        <button id="search-x-close-button" class="modal-close-button">&times;</button>
        
        <!-- Search header section with centered layout -->
        <div class="modal-search-header" style="text-align: center; margin-bottom: 2rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border-color);">
          <h2 id="search-title" style="margin: 0 0 1.25rem 0; font-size: 1.75rem;">Search for Mods</h2>
          
          <!-- Duplicate search box inside modal -->
          <div class="search-container" style="max-width: 300px; margin: 0 auto;">
            <input type="text" id="modal-search-input" placeholder="Find mods by name..." style="width: 100%; margin-left: 0;">
            <button id="modal-search-clear-button" class="search-clear-button">&times;</button>
          </div>
        </div>
        
        <div id="search-results-container">
          <p>Start typing in the search bar to find mods.</p>
        </div>
        <div class="modal-actions">
          <button id="search-close-button" class="clear-all-button">Close</button>
        </div>
      </div>
    </div>

    <!-- FOOTER -->
    <footer>
      <div class="footer-content">
        <div class="footer-column">
          <h4>About</h4>
          <ul>
            <li>
              <a
                href="https://github.com/BryantWelch/mcmodupdate.app"
                target="_blank"
                rel="noopener noreferrer"
                >GitHub Repository</a
              >
            </li>
            <li>
              <a
                href="https://github.com/BryantWelch/mcmodupdate.app/issues"
                target="_blank"
                rel="noopener noreferrer"
                >Report an Issue</a
              >
            </li>
            <li>
              <a
                href="https://github.com/BryantWelch/mcmodupdate.app/blob/main/CONTRIBUTING.md"
                target="_blank"
                rel="noopener noreferrer"
                >Contribute</a
              >
            </li>
            <li>
              <a
                href="https://github.com/BryantWelch/mcmodupdate.app/releases"
                target="_blank"
                rel="noopener noreferrer"
                >Releases</a
              >
            </li>
          </ul>
        </div>
        <div class="footer-column">
          <h4>Resources</h4>
          <ul>
            <li>
              <a
                href="https://modrinth.com"
                target="_blank"
                rel="noopener noreferrer"
                >Modrinth Official</a
              >
            </li>
            <li>
              <a
                href="https://www.curseforge.com/minecraft/mc-mods"
                target="_blank"
                rel="noopener noreferrer"
                >CurseForge Mods</a
              >
            </li>
            <li>
              <a
                href="https://fabricmc.net/"
                target="_blank"
                rel="noopener noreferrer"
                >FabricMC</a
              >
            </li>
            <li>
              <a
                href="https://neoforged.net/"
                target="_blank"
                rel="noopener noreferrer"
                >NeoForged</a
              >
            </li>
          </ul>
        </div>
        <div class="footer-column">
          <h4>Community</h4>
          <ul>
            <li>
              <a
                href="https://www.reddit.com/r/ModdedMinecraft/"
                target="_blank"
                rel="noopener noreferrer"
                >r/ModdedMinecraft</a
              >
            </li>
            <li>
              <a
                href="https://www.reddit.com/r/feedthebeast/"
                target="_blank"
                rel="noopener noreferrer"
                >r/feedthebeast</a
              >
            </li>
            <li>
                <a
                href="https://discord.gg/moddedmc"
                target="_blank"
                rel="noopener noreferrer"
                >Modded Minecraft Discord</a
              >
            </li>
            <li>
              <a
                href="https://discord.fabricmc.net/"
                target="_blank"
                rel="noopener noreferrer"
                >Fabric Project Discord</a
              >
            </li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p>
                      &copy; <span id="current-year">2025</span> Bryant Welch. Open source under 
          <a href="https://github.com/BryantWelch/mcmodupdate.app/blob/main/LICENSE" target="_blank" rel="noopener noreferrer">License</a>.
        </p>
        <a
          href="https://ko-fi.com/bryantwelch"
          target="_blank"
          rel="noopener noreferrer"
          class="kofi-button"
          title="Support the developer!"
        >
          <img
            src="https://storage.ko-fi.com/cdn/kofi5.png?v=6"
            alt="Buy Me a Coffee at ko-fi.com"
          />
        </a>
      </div>
    </footer>

    <!-- SCROLL BUTTONS -->
    <div id="scroll-buttons-container">
      <button id="scroll-to-top-btn" class="scroll-btn" title="Scroll to top"> <!-- "Scroll to Top" button is first -->
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="17 11 12 6 7 11"></polyline>
          <polyline points="17 18 12 13 7 18"></polyline>
        </svg>
      </button>
      <button id="scroll-to-bottom-btn" class="scroll-btn" title="Scroll to bottom"> <!-- "Scroll to Bottom" button is second -->
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="7 13 12 18 17 13"></polyline>
          <polyline points="7 6 12 11 17 6"></polyline>
        </svg>
      </button>
    </div>

    <script>
      // --- Global State ---
      let uploadedFiles = new Map();
      let successfulDownloads = [];
      let sectionCounts = {};
      let renderedModIds = new Set();
      let searchedMods = new Map();
      let mrpackMods = new Map(); // For mods from .mrpack files
      let isCurrentlySearching = false;
      let welcomeMessageSnapshot = null; // Store the welcome message snapshot
      let apiCallCount = 0; // Track total API calls made
      let processingStartTime = 0; // Track when processing started
      let dependencyMap = new Map(); // Track which mod requires each dependency
      let reverseDependencyMap = new Map(); // Track what dependencies each mod has
      let modIdToNameMap = new Map(); // Track mod ID to name mapping
      
      // Default mod icon as a data URL
      const DEFAULT_MOD_ICON = 'data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgaWQ9Ik1pbmVjcmFmdCI+PHBhdGggZD0ibTIxIDFoLTE4YTIgMiAwIDAgMCAtMiAydjE4YTIgMiAwIDAgMCAyIDJoMThhMiAyIDAgMCAwIDItMnYtMThhMiAyIDAgMCAwIC0yLTJ6bS0xNSA4LjV2LTNhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYzYS41LjUgMCAwIDEgLS41LjVoLTNhLjUuNSAwIDAgMSAtLjUtLjV6bTExIDhhLjUuNSAwIDAgMSAtLjUuNWgtMmEuNS41IDAgMCAxIC0uNS0uNXYtMS41aC00djEuNWEuNS41IDAgMCAxIC0uNS41aC0yYS41LjUgMCAwIDEgLS41LS41di01YS41LjUgMCAwIDEgLjUtLjVoMi41di0xLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxLjVoMi41YS41LjUgMCAwIDEgLjUuNXptMS04YS41LjUgMCAwIDEgLS41LjVoLTNhLjUuNSAwIDAgMSAtLjUtLjV2LTNhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXoiIGZpbGw9IiMzMDNjNDIiLz48L2c+PC9zdmc+';

      // --- DOM Element References ---
      const dropzone = document.getElementById("dropzone");
      const dropzonePrompt = document.getElementById("dropzone-prompt");
      const fileListContainer = document.getElementById("file-list-container");
      const fileInput = document.getElementById("file-input");
      const infoButton = document.getElementById("info-button");
      const infoModal = document.getElementById("info-modal");
      const modalCloseButton = document.getElementById("modal-close-button");
      const mcVersionSelect = document.getElementById("mc-version");
      const updateButton = document.getElementById("update-button");
      const updateButtonIcon = updateButton.querySelector("svg");
      const modLoaderSelect = document.getElementById("mod-loader");
      const resultsArea = document.getElementById("results-area");
      const progressBarContainer = document.getElementById("progress-bar-container");
      const progressBar = document.getElementById("progress-bar");
      const statusMessage = document.getElementById("status-message");
      const clearAllButton = document.getElementById("clear-all-button");
      const alertModal = document.getElementById("alert-modal");
      const alertMessage = document.getElementById("alert-message");
      const alertOkButton = document.getElementById("alert-ok-button");
      const alertIcon = document.getElementById("alert-icon");
      const alertTitle = document.getElementById("alert-title");
      const scrollToTopBtn = document.getElementById("scroll-to-top-btn");
      const scrollToBottomBtn = document.getElementById("scroll-to-bottom-btn");
      const searchInput = document.getElementById("mod-search");
      const modalSearchInput = document.getElementById("modal-search-input");
      const searchModal = document.getElementById("search-modal");
      const searchResultsContainer = document.getElementById("search-results-container");
      const searchCloseButton = document.getElementById("search-close-button");
      const searchXCloseButton = document.getElementById("search-x-close-button");
      const searchClearButton = document.getElementById("search-clear-button");
      const modalSearchClearButton = document.getElementById("modal-search-clear-button");
      const clearResultsButton = document.getElementById("clear-results-button");

      // --- UI LOGIC ---
      infoButton.addEventListener("click", () => {
        infoModal.classList.add("visible");
      });
      modalCloseButton.addEventListener("click", () => {
        infoModal.classList.remove("visible");
      });
      infoModal.addEventListener("click", (event) => {
        if (event.target === infoModal) {
          infoModal.classList.remove("visible");
        }
      });

      // --- Clear Results Button Logic ---
      clearResultsButton.addEventListener("click", resetResults);

      // --- Custom Alert Modal Logic ---
      function showCustomAlert(message, type = "notice", customTitle = null) {
        const icons = {
          notice: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--warning-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`,
          error: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--error-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>`,
        };
        const titles = {
          notice: "Notice",
          error: "Error",
        };

        // Use custom title if provided, otherwise use default for the type
        const titleText = customTitle || titles[type] || "Notice";
        
        // Set the text content of the title, excluding the icon
        alertTitle.childNodes[1].nodeValue = titleText;
        alertIcon.innerHTML = icons[type] || icons.notice;
        
        alertMessage.textContent = message;
        alertModal.classList.add("visible");
      }

      function hideCustomAlert() {
        alertModal.classList.remove("visible");
      }

      alertOkButton.addEventListener("click", hideCustomAlert);
      alertModal.addEventListener("click", (event) => {
        if (event.target === alertModal) {
          hideCustomAlert();
        }
      });

      // --- Scroll to Top/Bottom Button Logic ---
      function handleScrollButtons() {
        const scrollY = window.scrollY;
        const pageHeight = document.documentElement.scrollHeight;
        const viewportHeight = document.documentElement.clientHeight;

        // First, check if the page is scrollable at all. If not, hide both and exit.
        if (pageHeight <= viewportHeight) {
          scrollToTopBtn.style.display = "none";
          scrollToBottomBtn.style.display = "none";
          return;
        }

        // --- "Scroll to Top" Button Logic ---
        // Show if we are NOT at the top.
        if (scrollY > 0) {
          scrollToTopBtn.style.display = "flex";
        } else {
          scrollToTopBtn.style.display = "none";
        }

        // --- "Scroll to Bottom" Button Logic ---
        // Show if we are NOT at the bottom.
        // The '- 1' is a small buffer for rounding issues.
        if (scrollY + viewportHeight < pageHeight - 1) {
          scrollToBottomBtn.style.display = "flex";
        } else {
          scrollToBottomBtn.style.display = "none";
        }
      }

      // Add click listeners for smooth scrolling
      scrollToTopBtn.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      scrollToBottomBtn.addEventListener("click", () => {
        window.scrollTo({
          top: document.documentElement.scrollHeight,
          behavior: "smooth",
        });
      });

      // Listen for scroll events to show/hide the buttons
      window.addEventListener("scroll", handleScrollButtons);

      // Listen for window resize to reposition search modal
      window.addEventListener("resize", () => {
        if (searchModal.classList.contains("visible")) {
          positionSearchModal();
        }
      });

      // --- Clear All Button Logic ---
      function clearDropzone() {
        // Clear the underlying file data
        uploadedFiles.clear();

        searchedMods.clear();
        mrpackMods.clear();

        // Clear the visual file pills from the UI
        fileListContainer.innerHTML = "";

        // Only hide the status message if we are NOT currently searching.
        if (!isCurrentlySearching) {
          statusMessage.classList.remove("visible");
        }

        // Reset the dropzone to its initial, non-expanded state
        dropzonePrompt.style.display = "block";
        dropzone.classList.remove("dropzone-expanded");

        // Hide the "Clear All" button since there's nothing to clear
        clearAllButton.style.display = "none";
      }

      // --- Mod Search Functionality ---
      let currentSearchQuery = "";
      let currentSearchOffset = 0;
      let totalSearchResults = 0;
      
      function debounce(func, delay) {
        let timeout;
        return function(...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), delay);
        };
      }

      async function performSearch(query, isLoadMore = false) {
        // --- Rybbit Analytics Event ---
        try {
          if (window.rybbit && query) { // Only track if there's a query
            window.rybbit.event('Search Interaction', {
              action: 'query',
              query: query,
              isLoadMore: isLoadMore,
              selectedLoader: modLoaderSelect.value,
              selectedMcVersion: mcVersionSelect.value
            });
          }
        } catch (e) {
          console.error('Rybbit analytics error:', e);
        }
        if (!query) {
          searchResultsContainer.innerHTML = "<p>Start typing to find mods.</p>";
          currentSearchQuery = "";
          currentSearchOffset = 0;
          totalSearchResults = 0;
          return;
        }

        // If this is a new search (not load more), reset everything
        if (!isLoadMore) {
          currentSearchQuery = query;
          currentSearchOffset = 0;
          searchResultsContainer.innerHTML = "<p>Searching...</p>";
        }

        const searchUrl = `https://api.modrinth.com/v2/search?query=${encodeURIComponent(query)}&limit=10&offset=${currentSearchOffset}`;
        try {
          const response = await fetchWithRetry(searchUrl);
          const data = await response.json();
          
          // Store total results count
          totalSearchResults = data.total_hits;
          
          if (isLoadMore) {
            appendSearchResults(data.hits);
          } else {
            renderSearchResults(data.hits);
          }
          
          // Update offset for next load
          currentSearchOffset += 10;
          
          // Show/hide load more button based on whether there are more results
          updateLoadMoreButton();
          
        } catch (error) {
          if (!isLoadMore) {
            searchResultsContainer.innerHTML = "<p>Error fetching search results.</p>";
          }
          console.error("Search failed:", error);
        }
      }

      async function loadMoreResults() {
        if (!currentSearchQuery) return;
        
        // Show loading state on the button
        const loadMoreBtn = document.getElementById("load-more-btn");
        if (loadMoreBtn) {
          loadMoreBtn.textContent = "Loading...";
          loadMoreBtn.disabled = true;
        }
        
        await performSearch(currentSearchQuery, true);
        
        // Reset button state
        if (loadMoreBtn) {
          loadMoreBtn.textContent = "Show 10 more";
          loadMoreBtn.disabled = false;
        }
      }

      function updateLoadMoreButton() {
        let loadMoreBtn = document.getElementById("load-more-btn");
        
        // Check if there are more results to load
        const hasMoreResults = currentSearchOffset < totalSearchResults;
        
        if (hasMoreResults && currentSearchQuery) {
          // Create button if it doesn't exist
          if (!loadMoreBtn) {
            loadMoreBtn = document.createElement("button");
            loadMoreBtn.id = "load-more-btn";
            loadMoreBtn.className = "action-button";
            loadMoreBtn.style.marginTop = "1rem";
            loadMoreBtn.style.width = "100%";
            loadMoreBtn.textContent = "Show 10 more";
            loadMoreBtn.addEventListener("click", loadMoreResults);
            searchResultsContainer.appendChild(loadMoreBtn);
          } else {
            loadMoreBtn.style.display = "block";
          }
          
          // Update button text with remaining count
          const remainingResults = totalSearchResults - currentSearchOffset;
          const showCount = Math.min(10, remainingResults);
          loadMoreBtn.textContent = `Show ${showCount} more`;
          
        } else if (loadMoreBtn) {
          // Hide button if no more results
          loadMoreBtn.style.display = "none";
        }
      }

      const debouncedSearch = debounce(performSearch, 600);

      // --- Position Search Modal Function ---
      function positionSearchModal() {
        const controlsElement = document.querySelector('.controls');
        const modalContent = document.querySelector('#search-modal .modal-content');
        
        if (controlsElement && modalContent) {
          const controlsRect = controlsElement.getBoundingClientRect();
          const controlsBottom = controlsRect.bottom + window.scrollY;
          
          // Position the modal 8px below the controls
          modalContent.style.top = `${controlsBottom + 8}px`;
        }
      }

      // Function to handle search input changes (used by both inputs)
      function handleSearchInput(query, sourceInput) {
        // Sync both inputs
        if (sourceInput !== searchInput) {
          searchInput.value = query;
        }
        if (sourceInput !== modalSearchInput) {
          modalSearchInput.value = query;
        }
        
        // Show or hide clear buttons for both inputs
        if (query.length > 0) {
          searchClearButton.classList.add("show");
          modalSearchClearButton.classList.add("show");
        } else {
          searchClearButton.classList.remove("show");
          modalSearchClearButton.classList.remove("show");
        }

        // Perform search
        if (query.length > 1) {
          positionSearchModal();
          searchModal.classList.add("visible");
          debouncedSearch(query);
        } else {
          searchResultsContainer.innerHTML = "<p>Start typing to find mods.</p>";
        }
      }

      // Function to clear search (used by both clear buttons)
      function clearSearch(focusInput) {
        // Clear both input fields
        searchInput.value = "";
        modalSearchInput.value = "";
        // Hide both clear buttons
        searchClearButton.classList.remove("show");
        modalSearchClearButton.classList.remove("show");
        // Reset the search results in the modal
        searchResultsContainer.innerHTML = "<p>Start typing to find mods.</p>";
        // Reset search state
        currentSearchQuery = "";
        currentSearchOffset = 0;
        totalSearchResults = 0;
        // Focus the specified input
        if (focusInput) {
          focusInput.focus();
        }
      }

      // Event listeners for both search inputs
      searchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim();
        handleSearchInput(query, searchInput);
      });

      modalSearchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim();
        handleSearchInput(query, modalSearchInput);
      });

      // Event listeners for both clear buttons
      searchClearButton.addEventListener("click", () => {
        clearSearch(searchInput);
      });

      modalSearchClearButton.addEventListener("click", () => {
        clearSearch(modalSearchInput);
      });
      
      // Focus event listeners for both search inputs
      searchInput.addEventListener("focus", () => {
        if(searchInput.value.trim().length > 1) {
            positionSearchModal();
            searchModal.classList.add("visible");
        }
      });

      modalSearchInput.addEventListener("focus", () => {
        if(modalSearchInput.value.trim().length > 1) {
            positionSearchModal();
            searchModal.classList.add("visible");
        }
      });

      // --- Search Modal Close Logic ---
      searchCloseButton.addEventListener("click", () => {
        searchModal.classList.remove("visible");
      });

      searchXCloseButton.addEventListener("click", () => {
        searchModal.classList.remove("visible");
      });

      searchModal.addEventListener("click", (event) => {
        // If the user clicks on the dark overlay itself, not the content
        if (event.target === searchModal) {
          searchModal.classList.remove("visible");
        }
      });

      // --- Search Modal Results Logic ---
      function renderSearchResults(hits) {
        searchResultsContainer.innerHTML = "";
        if (hits.length === 0) {
          searchResultsContainer.innerHTML = "<p>No mods found.</p>";
          return;
        }
        hits.forEach(hit => {
          const card = createSearchResultCard(hit);
          searchResultsContainer.appendChild(card);
        });
      }

      function appendSearchResults(hits) {
        // Remove the load more button temporarily if it exists
        const loadMoreBtn = document.getElementById("load-more-btn");
        if (loadMoreBtn) {
          loadMoreBtn.remove();
        }
        
        // Add new result cards
        hits.forEach(hit => {
          const card = createSearchResultCard(hit);
          searchResultsContainer.appendChild(card);
        });
      }

      // --- Search Modal Results Card Logic ---
      function createSearchResultCard(mod) {
        const card = document.createElement("div");
        card.className = "result-card";
        
        // The project URL is consistent for all links
        const projectUrl = `https://modrinth.com/project/${mod.slug}`;
        const authorUrl = `https://modrinth.com/user/${mod.author}`;

        // Get client/server support info using the same function as success cards
        const clientServerInfo = getClientServerSupport(mod.client_side, mod.server_side);

        card.innerHTML = `
          <div class="result-card-main">
            <a href="${projectUrl}" target="_blank" rel="noopener noreferrer" class="mod-icon-link">
              <img src="${mod.icon_url || DEFAULT_MOD_ICON}" alt="${mod.title} icon" class="mod-icon" onerror="this.src=DEFAULT_MOD_ICON">
            </a>
            <div class="mod-details">
              <div class="mod-title">
                <a href="${projectUrl}" target="_blank" rel="noopener noreferrer">${mod.title}</a>
                ${mod.project_type ? `<span class="mod-title-tag">(${mod.project_type.charAt(0).toUpperCase() + mod.project_type.slice(1)})</span>` : ''}
              </div>
              <div class="mod-author">
                by <a href="${authorUrl}" target="_blank" rel="noopener noreferrer">${mod.author}</a>
              </div>
              <div class="mod-description">${mod.description}</div>
              <div class="mod-meta">
                <div class="mod-meta-item meta-tooltip-container">
                  ${clientServerInfo.svg}
                  <span>${clientServerInfo.text}</span>
                  <span class="meta-tooltip">Supported Environments</span>
                </div>
                <div class="mod-meta-item meta-tooltip-container">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
                  <span class="mod-meta-date">${formatTimeAgo(mod.date_modified)}</span>
                  <span class="meta-tooltip">Last Updated</span>
                </div>
                <div class="mod-meta-item meta-tooltip-container">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                  <span>${formatDownloads(mod.downloads)}</span>
                  <span class="meta-tooltip">Total Downloads</span>
                </div>
                <div class="mod-meta-item meta-tooltip-container">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                  </svg>
                  <span>${formatDownloads(mod.follows)}</span>
                  <span class="meta-tooltip">Followers</span>
                </div>
                <div class="mod-meta-item category-tooltip-container" style="display: none;">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2H2v10l9.29 9.29a1 1 0 0 0 1.42 0l8-8a1 1 0 0 0 0-1.42L12 2z"></path>
                    <path d="M7 7h.01"></path>
                  </svg>
                  <span class="category-tooltip"></span>
                </div>
              </div>
            </div>
            <div class="mod-actions">
              <button class="add-mod-button" data-slug="${mod.slug}" data-project-id="${mod.project_id}" data-title="${mod.title}">Add</button>
            </div>
          </div>`;

        // Populate Category Tooltip if categories exist - using display_categories for cleaner results
        const categoriesToShow = mod.display_categories || mod.categories;
        if (categoriesToShow && categoriesToShow.length > 0) {
          const categoryContainer = card.querySelector(".category-tooltip-container");
          const categoryTooltip = card.querySelector(".category-tooltip");

          // Format category names (turn "world-gen" into "World Gen")
          function formatCategoryName(slug) {
            return slug
              .split("-")
              .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
              .join(" ");
          }

          // Use the same simple approach as success/warning cards
          const formattedCategories = categoriesToShow.map(formatCategoryName);
          categoryTooltip.textContent = formattedCategories.join(", ");

          // Make the category icon visible
          categoryContainer.style.display = "flex";
        }

        const addButton = card.querySelector(".add-mod-button");
        // Disable button if already added
        if (searchedMods.has(mod.project_id) || renderedModIds.has(mod.slug)) {
            addButton.disabled = true;
            addButton.textContent = "Added";
        }

        addButton.addEventListener("click", (e) => {
          const slug = e.target.dataset.slug;
          const projectId = e.target.dataset.projectId;
          const title = e.target.dataset.title;

          // --- Rybbit Analytics Event ---
          try {
            if (window.rybbit) {
              window.rybbit.event('Search Interaction', {
                action: 'add_from_results',
                modTitle: title,
                selectedLoader: modLoaderSelect.value,
                selectedMcVersion: mcVersionSelect.value
              });
            }
          } catch (err) {
            console.error('Rybbit analytics error:', err);
          }

          if (!searchedMods.has(projectId)) {
            searchedMods.set(projectId, { title: title });
            createFilePill({ name: `${title} (Searched)` });
            dropzonePrompt.style.display = "none";
            dropzone.classList.add("dropzone-expanded");
            clearAllButton.style.display = "inline-flex";
          }
          
          e.target.disabled = true;
          e.target.textContent = "Added";
          searchModal.classList.remove("visible");
        });

        return card;
      }

      clearAllButton.addEventListener("click", clearDropzone);

      ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        dropzone.addEventListener(eventName, (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      });
      ["dragenter", "dragover"].forEach((eventName) => {
        dropzone.addEventListener(eventName, () => {
          dropzone.classList.add("dragover");
        });
      });
      ["dragleave", "drop"].forEach((eventName) => {
        dropzone.addEventListener(eventName, () => {
          dropzone.classList.remove("dragover");
        });
      });
      dropzone.addEventListener("drop", (event) => {
        handleFiles(event.dataTransfer.files);
      });
      dropzone.addEventListener("click", (event) => {
        if (
          !event.target.classList.contains("file-pill-remove") &&
          !event.target.closest(".file-pill-remove")
        ) {
          fileInput.click();
        }
      });
      fileInput.addEventListener("change", (event) => {
        if (event.target.files.length > 0) {
          handleFiles(event.target.files);
        }
        event.target.value = null;
      });

      function handleFiles(files) {
        if (files.length === 0) return;

        // Check if a .mrpack file is among the dropped files
        const mrpackFile = Array.from(files).find((file) =>
          file.name.endsWith(".mrpack")
        );

        if (mrpackFile) {
          // If a modpack is found, clear everything and process only the pack.
          clearDropzone();
          // Add the .mrpack file itself to uploadedFiles so it can be updated as a whole package
          uploadedFiles.set(mrpackFile.name, mrpackFile);
          processMrpack(mrpackFile);
        } else {
          // Separate validation for better error messages
          const acceptedFiles = Array.from(files).filter(file => file.name.endsWith('.jar') || file.name.endsWith('.zip'));
          const duplicateFiles = acceptedFiles.filter(file => uploadedFiles.has(file.name));
          const validFiles = acceptedFiles.filter(file => !uploadedFiles.has(file.name));
          const invalidFiles = Array.from(files).filter(file => !file.name.endsWith('.jar') && !file.name.endsWith('.zip'));

          if (validFiles.length > 0) {
            // Only update UI if we have valid files
            dropzonePrompt.style.display = "none";
            dropzone.classList.add("dropzone-expanded");
            clearAllButton.style.display = "inline-flex";

            for (const file of validFiles) {
              uploadedFiles.set(file.name, file);
              createFilePill(file);
            }
          } else {
            // Provide specific error messages based on what went wrong
            if (duplicateFiles.length > 0 && invalidFiles.length === 0) {
              // Only duplicates
              const fileNames = duplicateFiles.map(f => f.name).join(", ");
              showCustomAlert(
                `The following file(s) are already uploaded: ${fileNames}`,
                "notice",
                "Duplicate Files"
              );
            } else if (duplicateFiles.length > 0 && invalidFiles.length > 0) {
              // Both duplicates and invalid files
              const duplicateNames = duplicateFiles.map(f => f.name).join(", ");
              showCustomAlert(
                `Some files are already uploaded (${duplicateNames}) and others are not valid. Please upload .jar, .zip, or .mrpack files.`,
                "notice",
                "Mixed File Issues"
              );
            } else {
              // Only invalid file types
              showCustomAlert(
                "Please upload valid files (.jar, .zip) or a Modrinth modpack (.mrpack).",
                "notice",
                "Invalid File Type"
              );
            }
          }
        }
      }

      // --- Process .mrpack file ---
      async function processMrpack(packFile) {
        try {
          // Update UI to show processing has started
          dropzonePrompt.style.display = "none";
          dropzone.classList.add("dropzone-expanded");
          clearAllButton.style.display = "inline-flex";
          // Create a pill for the .mrpack file itself (to be updated as a whole)
          createFilePill(packFile);
          // Also create a temporary processing pill
          createFilePill({ name: `Processing: ${packFile.name}...` }); // Temporary pill

          const zip = await JSZip.loadAsync(packFile);
          const manifestFile = zip.file("modrinth.index.json");

          if (!manifestFile) {
            showCustomAlert(
              "The uploaded file is not a valid Modrinth modpack (missing modrinth.index.json).",
              "error"
            );
            clearDropzone(); // Clear the "Processing..." pill
            return;
          }

          const content = await manifestFile.async("string");
          const manifest = JSON.parse(content);

          // Clear only the temporary "Processing..." pill but keep the .mrpack pill
          const processingPill = Array.from(fileListContainer.children).find(pill => 
            pill.querySelector('span').textContent.startsWith('Processing:'));
          if (processingPill) {
            processingPill.remove();
          }

          // --- Informational Message: Get Source Version and Loader ---
          let sourceVersion = "unknown";
          let sourceLoader = "unknown";

          if (manifest.dependencies) {
            if (manifest.dependencies.minecraft) {
              sourceVersion = manifest.dependencies.minecraft;
            }
            if (manifest.dependencies["fabric-loader"]) {
              sourceLoader = "Fabric";
            } else if (manifest.dependencies.forge) {
              sourceLoader = "Forge";
            } else if (manifest.dependencies["quilt-loader"]) {
              sourceLoader = "Quilt";
            } else if (manifest.dependencies.neoforge) {
              sourceLoader = "NeoForge";
            }
          }

          statusMessage.textContent = `Detected: ${sourceLoader} pack for MC ${sourceVersion}. Ready to find updates for your selected version.`;
          statusMessage.classList.add("visible");
          // --- END of Informational Message: Get Source Version and Loader ---

          // The manifest.files array contains the list of mods
          if (manifest.files && manifest.files.length > 0) {
            for (const modFile of manifest.files) {
              // The path often looks like "mods/fabric-api-0.91.0.jar"
              const filename = modFile.path.split("/").pop();
              const sha1Hash = modFile.hashes.sha1;

              if (sha1Hash && filename) {
                // Use the hash as the unique key and store the filename for display.
                // This uses the new `mrpackMods` map to keep them separate.
                mrpackMods.set(sha1Hash, { title: filename });
                createFilePill({ name: filename });
              }
            }
          }
        } catch (error) {
          console.error("Error processing .mrpack file:", error);
          showCustomAlert(
            "Could not read the uploaded .mrpack file. It may be corrupt.",
            "error"
          );
          clearDropzone();
        }
      }


      // --- File Pill Logic ---
      function createFilePill(file) {
        const filePill = document.createElement("div");
        filePill.classList.add("file-pill");
        const fileNameSpan = document.createElement("span");
        fileNameSpan.textContent = file.name;
        filePill.appendChild(fileNameSpan);
        const removeButton = document.createElement("span");
        removeButton.classList.add("file-pill-remove");
        removeButton.innerHTML = "&times;";
        removeButton.setAttribute("role", "button");
        removeButton.setAttribute("tabindex", "0");
        removeButton.setAttribute("aria-label", "Remove " + file.name);
        removeButton.onclick = function (event) {
          event.stopPropagation();
          uploadedFiles.delete(file.name);
          filePill.remove();
          if (uploadedFiles.size === 0) {
            dropzonePrompt.style.display = "block";
            dropzone.classList.remove("dropzone-expanded");
            clearAllButton.style.display = "none"; // HIDE THE BUTTON
          }
        };
        removeButton.onkeydown = function (event) {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            removeButton.onclick(event);
          }
        };
        filePill.appendChild(removeButton);
        fileListContainer.appendChild(filePill);
      }

      document.getElementById("current-year").textContent =
        new Date().getFullYear();

// --- Dynamic Minecraft Version Loading with Hierarchical Layout ---
async function populateMcVersions() {
  try {
    const response = await fetch(
      "https://api.modrinth.com/v2/tag/game_version"
    );
    if (!response.ok) throw new Error("Failed to fetch MC versions");
    const versions = await response.json();

    // Filter for release versions and sort them numerically descending
    const releaseVersions = versions
      .filter(
        (v) =>
          v.version_type === "release" &&
          /^\d+\.\d+(\.\d+)?$/.test(v.version)
      )
      .sort((a, b) => {
        const aParts = a.version.split(".").map(Number);
        const bParts = b.version.split(".").map(Number);
        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
          const aVal = aParts[i] || 0;
          const bVal = bParts[i] || 0;
          if (aVal !== bVal) return bVal - aVal; // Sort descending
        }
        return 0;
      });

    const groupedVersions = {};

    // Group versions by their major release (e.g., "1.21.6" -> "1.21")
    releaseVersions.forEach((versionObj) => {
      // Access the .version property of the object
      const versionStr = versionObj.version;
      const parts = versionStr.split(".");

      if (parts.length >= 2) {
        const majorVersion = `${parts[0]}.${parts[1]}`;
        if (!groupedVersions[majorVersion]) {
          groupedVersions[majorVersion] = [];
        }
        // Only add patch versions (like 1.21.6) to the sub-list
        if (parts.length > 2) {
          // Push the version string, not the whole object
          groupedVersions[majorVersion].push(versionStr);
        }
      }
    });

    // Get the major versions and sort them again to ensure order
    const sortedMajorVersions = Object.keys(groupedVersions).sort((a, b) => {
      const aParts = a.split(".").map(Number);
      const bParts = b.split(".").map(Number);
      for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        const aVal = aParts[i] || 0;
        const bVal = bParts[i] || 0;
        if (aVal !== bVal) return bVal - aVal;
      }
      return 0;
    });

    mcVersionSelect.innerHTML = ""; // Clear existing options

    // Populate the dropdown with the hierarchical structure
    sortedMajorVersions.forEach((majorVersion) => {
      // Add the main version entry (e.g., 1.21)
      const mainOption = document.createElement("option");
      mainOption.value = majorVersion;
      mainOption.textContent = majorVersion;
      mcVersionSelect.appendChild(mainOption);

      // Add the indented sub-version entries (e.g., 1.21.6, 1.21.5)
      const subVersions = groupedVersions[majorVersion];
      subVersions.forEach((subVersion) => {
        const subOption = document.createElement("option");
        subOption.value = subVersion;
        // Use non-breaking spaces for indentation
        subOption.innerHTML = `&nbsp;&nbsp;${subVersion}`;
        mcVersionSelect.appendChild(subOption);
      });
    });

    // Select the latest version by default
    if (mcVersionSelect.options.length > 0) {
      mcVersionSelect.options[0].selected = true;
    }
  } catch (error) {
    console.error("A real error occurred:", error); // Changed for better debugging
    // Fallback or show an error
    mcVersionSelect.innerHTML =
      '<option value="1.21">Error loading versions</option>';
    showCustomAlert(
      "Could not load Minecraft versions from Modrinth. Please check your connection and refresh.",
      "error"
    );
  }
}

// Call these functions when the page loads
document.addEventListener("DOMContentLoaded", () => {
  populateMcVersions();
  handleScrollButtons(); // This runs our check once on load
  
  // Clear both search inputs on page load/refresh
  searchInput.value = "";
  modalSearchInput.value = "";
  
  // Capture the welcome message snapshot
  welcomeMessageSnapshot = resultsArea.innerHTML;
});

// --- UI State Reset Function ---
function resetResults() {
  // Restore the welcome message from snapshot
  if (welcomeMessageSnapshot) {
    resultsArea.innerHTML = welcomeMessageSnapshot;
  } else {
    // Fallback if snapshot isn't available
    resultsArea.innerHTML = "";
  }

  // Hide the progress bar and status message
  progressBarContainer.style.display = "none";
  progressBar.style.width = "0%";
  statusMessage.classList.remove("visible");

  // Reset the data arrays
  successfulDownloads = [];
  sectionCounts = { found: 0, warning: 0, failure: 0 };

  // Reset sort states
  if (window.resetSortStates) {
    window.resetSortStates();
  }

  // Hide the "Clear Results" button
  clearResultsButton.style.display = "none";

  // Re-enable the update button
  updateButton.disabled = false;
  updateButton.innerHTML = `Update
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
      <polyline points="17 8 12 3 7 8"></polyline>
      <line x1="12" y1="3" x2="12" y2="15"></line>
    </svg>`;
}

// --- Main Update Logic with Live Rendering and Dependency Resolution ---
updateButton.addEventListener("click", handleUpdate);

async function handleUpdate() {
    // --- Rybbit Analytics Event ---
    try {
      if (window.rybbit) {
        const jarFiles = Array.from(uploadedFiles.values()).filter(f => f.name.endsWith('.jar'));
        const mrpackFiles = Array.from(uploadedFiles.values()).filter(f => f.name.endsWith('.mrpack'));

        window.rybbit.event('Update Mods Clicked', {
          totalFiles: uploadedFiles.size,
          jarFileCount: jarFiles.length,
          mrpackFileCount: mrpackFiles.length,
          mrpackModsCount: mrpackMods.size, // Added for .mrpack mods
          searchedModsCount: searchedMods.size,
          selectedLoader: modLoaderSelect.value,
          selectedMcVersion: mcVersionSelect.value
        });
      }
    } catch (e) {
      console.error('Rybbit analytics error:', e);
    }
  // Combine jobs from both sources first.
  const fileJobs = Array.from(uploadedFiles.values()).map((file) => {
    // Create a special job type for .mrpack files to handle them as modpacks
    if (file.name.endsWith(".mrpack")) {
      return {
        type: "mrpack",
        data: file,
        isMrpackFile: true, // Flag to identify it's the actual .mrpack file
      };
    }
    return {
      type: "file",
      data: file,
    };
  });
  const searchJobs = Array.from(searchedMods.entries()).map(
    ([key, modInfo]) => {
      const isHash = /^[a-f0-9]{40}$/.test(key);
      return {
        type: isHash ? "hash" : "id",
        data: key,
        title: modInfo.title,
      };
    }
  );
  const mrpackJobs = Array.from(mrpackMods.entries()).map(([key, modInfo]) => ({
    type: "hash", // .mrpack mods are always identified by hash
    data: key,
    title: modInfo.title,
  }));

  const jobs = [...fileJobs, ...searchJobs, ...mrpackJobs];

  // Check if there's anything to do.
  if (jobs.length === 0) {
    showCustomAlert("Please upload or search for mods first.", "notice");
    return;
  }

  // --- START of new logic ---
  isCurrentlySearching = true;
  try {
    // --- END of new logic ---

    // Reset the UI and state for a new run.
    resetResults();
    renderedModIds.clear();
    dependencyMap.clear(); // Reset dependency tracking
    reverseDependencyMap.clear(); // Reset reverse dependency tracking
    modIdToNameMap.clear(); // Reset mod name mapping
    apiCallCount = 0; // Reset API call counter
    processingStartTime = Date.now(); // Start timing
    cacheStats = { hits: 0, misses: 0, stores: 0 }; // Reset cache stats for this run
    updateButton.disabled = true;
    updateButton.innerHTML = "Searching...";
    statusMessage.textContent = "Searching for updates and dependencies...";
    statusMessage.classList.add("visible");
    setupResultSections();
    progressBarContainer.style.display = "block";

    const processedIds = new Set();
    let allJobs = [...jobs];
    let completedJobs = 0;
    const allDependencies = new Set(); // Store all discovered dependencies

    // Phase 1: Process all initial mods in batches
    statusMessage.textContent = `Searching updates for ${jobs.length} mods...`;
    while (allJobs.length > 0) {
      const batchSize = 25;
      const currentBatch = allJobs.splice(0, batchSize);
      
      const results = await getModUpdateInfoBatch(currentBatch, batchSize);
      
      // Process and render results immediately as each batch completes
      for (const result of results) {
        const key = result.modId || (result.title + result.reason);
        
        if (processedIds.has(key)) {
          completedJobs++;
          continue;
        }
        processedIds.add(key);

        // Collect dependencies BEFORE rendering the card
        if (result.status === "success" && result.dependencies) {
          const requiredDeps = [];
          for (const dep of result.dependencies) {
            if (dep.dependency_type === "required") {
              allDependencies.add(dep.project_id);
              // Track which mod requires this dependency
              dependencyMap.set(dep.project_id, result.title);
              // Track dependencies for this mod (reverse mapping)
              requiredDeps.push(dep.project_id);
            }
          }
          // Store what dependencies this mod has
          if (requiredDeps.length > 0) {
            // Store dependencies for reverse lookup
            reverseDependencyMap.set(result.projectId, requiredDeps);
          }
        }

        if (result.status === "success" && renderedModIds.has(result.modId)) {
        } else {
          renderSingleResult(result);
          if (result.status === "success") {
            renderedModIds.add(result.modId);
            // Store mod ID to name mapping for dependency tooltips
            modIdToNameMap.set(result.projectId, result.title);
            
            // Add to successfulDownloads if it has the required download info
            // This handles both cached and fresh results
            if (result.all_versions && result.all_versions.length > 0) {
              const latestVersion = result.all_versions.find(v => v.version_type === "release") || 
                                   result.all_versions.find(v => v.version_type === "beta") || 
                                   result.all_versions.find(v => v.version_type === "alpha");
              
              if (latestVersion) {
                const primaryFile = latestVersion.files.find(f => f.primary);
                if (primaryFile) {
                  const downloadInfo = {
                    url: primaryFile.url,
                    filename: primaryFile.filename,
                    hashes: primaryFile.hashes,
                    path: `mods/${primaryFile.filename}`,
                    fileSize: primaryFile.size,
                    client_side: result.client_side,
                    server_side: result.server_side,
                    projectId: result.projectId,
                  };
                  
                  // Check if this download info is already in the array (avoid duplicates)
                  const isDuplicate = successfulDownloads.some(dl => dl.projectId === result.projectId);
                  if (!isDuplicate) {
                    successfulDownloads.push(downloadInfo);
                  }
                }
              }
            }
          }
        }
        
        completedJobs++;
      }
      
      // Update progress bar after each batch (50% for initial mods)
      const progressPercentage = Math.min((completedJobs / jobs.length) * 50, 50);
      progressBar.style.width = `${progressPercentage}%`;
      
      // Add a small delay to let the UI update and show the new results
      if (allJobs.length > 0) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

        // Phase 2: Recursively process dependencies
    let dependencyQueue = Array.from(allDependencies).filter(depId => !processedIds.has(depId));
    let actualDependenciesAdded = 0;
    const totalInitialDependencies = dependencyQueue.length;
    let dependenciesProcessed = 0;

    while (dependencyQueue.length > 0) {
      const currentBatchIds = dependencyQueue.splice(0, 25); // Process in batches
      statusMessage.textContent = `Resolving dependencies... (${dependenciesProcessed}/${totalInitialDependencies} initial, ${dependencyQueue.length} in queue)`;

      const dependencyJobs = currentBatchIds.map(depId => ({
        type: 'id',
        data: depId,
        title: `Dependency: ${depId}`,
        isDependencyJob: true,
      }));

      const results = await getModUpdateInfoBatch(dependencyJobs, dependencyJobs.length);

      for (const result of results) {
        const key = result.modId || result.projectId || (result.title + result.reason);

        if (processedIds.has(key)) {
          if (result.status === "success" && result.projectId) {
            updateDependencyChainTooltip(result.projectId, result.title);
          }
          continue;
        }
        processedIds.add(key);
        dependenciesProcessed++;

        // Render the dependency card
        renderSingleResult(result);

        if (result.status === "success") {
          actualDependenciesAdded++;
          renderedModIds.add(result.modId);
          modIdToNameMap.set(result.projectId, result.title);
          updateDependencyChainTooltip(result.projectId, result.title);

          // Check for nested dependencies
          if (result.dependencies) {
            for (const dep of result.dependencies) {
              if (dep.dependency_type === "required") {
                const depKey = dep.project_id;
                if (!processedIds.has(depKey) && !dependencyQueue.includes(depKey)) {
                  dependencyQueue.push(depKey); // Add new dependency to the queue
                  allDependencies.add(depKey); // Keep track of all unique dependencies
                  dependencyMap.set(depKey, result.title); // Track who requires this

                  // A new dependency relationship was found, so we might need to update the parent's card
                  const parentProjectId = result.projectId;
                  if (parentProjectId) {
                     // Update the reverse map before calling the card update
                    if (!reverseDependencyMap.has(parentProjectId)) {
                      reverseDependencyMap.set(parentProjectId, []);
                    }
                    reverseDependencyMap.get(parentProjectId).push(depKey);
                    updateDependencyChainOnCard(parentProjectId);
                  }
                }
              }
            }
          }
        }
      }

      // Update progress bar (from 50% to 95% during dependency phase)
      const totalDependencies = allDependencies.size;
      const processedDependencyCount = Array.from(allDependencies).filter(id => processedIds.has(id)).length;
      const depProgressPercentage = 50 + (Math.min(processedDependencyCount / (totalDependencies || 1), 1) * 45);
      progressBar.style.width = `${depProgressPercentage}%`;

      if (dependencyQueue.length > 0) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    // Complete the progress bar and create summary
    progressBar.style.width = "100%";
    
    finalizeResultsUI();
    
    // Create comprehensive summary
    const updatesFound = sectionCounts.found || 0;
    const notCompatible = sectionCounts.warning || 0;
    const notFound = sectionCounts.failure || 0;
    const dependenciesAdded = actualDependenciesAdded || 0;
    
    // Calculate processing time
    const processingTime = ((Date.now() - processingStartTime) / 1000).toFixed(1);
    
    let summaryText = `Updates found: ${updatesFound}`;
    if (notCompatible > 0) summaryText += `, Not compatible: ${notCompatible}`;
    if (notFound > 0) summaryText += `, Failed to find: ${notFound}`;
    if (dependenciesAdded > 0) summaryText += `, Dependencies added: ${dependenciesAdded}`;
    
    // Add processing time, API calls, and cache info
    // Count unique mods that were cached vs fresh (include both success and warning results)
    const allCards = document.querySelectorAll('#results-found .result-card, #results-warning .result-card');
    let cachedModCount = 0;
    let freshModCount = 0;
    
    allCards.forEach(card => {
      const hasCacheIcon = card.querySelector('.cache-icon');
      if (hasCacheIcon) {
        cachedModCount++;
      } else {
        freshModCount++;
      }
    });
    
    summaryText += `<br>Processing time: ${processingTime}s, API calls used: ${apiCallCount}`;
    if (cachedModCount + freshModCount > 0) {
      summaryText += `<br>Cached lookups: ${cachedModCount}, Fresh lookups: ${freshModCount}`;
    }
    
    // Store the summary for the finally block
    window.finalSummaryText = summaryText;
    statusMessage.innerHTML = summaryText;
    // Keep the status message visible instead of hiding it

    setTimeout(() => {
      progressBarContainer.style.display = "none";
    }, 1000);

    
  } catch (error) {
    console.error("Error in handleUpdate:", error);
    statusMessage.textContent = `Error processing mods: ${error.message}`;
    statusMessage.classList.add("visible");
    
    // Reset UI state on error
    progressBarContainer.style.display = "none";
  } finally {
    isCurrentlySearching = false;
    // Always reset the button state
    updateButton.disabled = false;
    updateButton.innerHTML = `Update
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
      </svg>`;
    
    // Ensure we show the final summary if it was calculated
    if (window.finalSummaryText && sectionCounts.found > 0) {
      statusMessage.innerHTML = window.finalSummaryText;
      statusMessage.classList.add("visible");
      window.finalSummaryText = null; // Clean up
    } else if (apiCallCount > 0) {
      // If we have API calls but no final summary, at least show the API count
      const fallbackTime = ((Date.now() - processingStartTime) / 1000).toFixed(1);
      
      // Count unique mods that were cached vs fresh (include both success and warning results)
      const allCards = document.querySelectorAll('#results-found .result-card, #results-warning .result-card');
      let cachedModCount = 0;
      let freshModCount = 0;
      
      allCards.forEach(card => {
        const hasCacheIcon = card.querySelector('.cache-icon');
        if (hasCacheIcon) {
          cachedModCount++;
        } else {
          freshModCount++;
        }
      });
      
      let fallbackSummary = `Processing completed<br>Processing time: ${fallbackTime}s, API calls used: ${apiCallCount}`;
      if (cachedModCount + freshModCount > 0) {
        fallbackSummary += `<br>Cached lookups: ${cachedModCount}, Fresh lookups: ${freshModCount}`;
      }
      statusMessage.innerHTML = fallbackSummary;
      statusMessage.classList.add("visible");
    }
  }
}

// --- API Fetcher with Transparent Rate Limit and Custom User-Agent ---
async function fetchWithRetry(url, options, retries = 3) {
  const requestOptions = {
    ...options, // Spread any existing options
          headers: {
        // Add our custom User-Agent following Modrinth's recommendations
        // "User-Agent": "BryantWelch/mcmodupdate.app/1.0.0 (https://github.com/BryantWelch/mcmodupdate.app)",
        ...(options?.headers || {})
      },
  };

  for (let i = 0; i < retries; i++) {
    // Use the new requestOptions object
    const response = await fetch(url, requestOptions);
    
    // Count successful API calls (including retries)
    if (response.ok) {
      apiCallCount++;
    }

    if (response.status === 429) {
      const resetTimestamp = Number(
        response.headers.get("X-Ratelimit-Reset")
      );
      const currentTime = Math.floor(Date.now() / 1000);
      const waitTime = resetTimestamp
        ? Math.max(0, resetTimestamp - currentTime) + 1
        : 10; // Default to 10 seconds if reset time is not available

      const originalMessage = statusMessage.textContent;
      console.warn(
        `Rate limited. Waiting for ${waitTime} seconds until the limit resets.`
      );
      
      // Show countdown for rate limiting
      for (let i = waitTime; i > 0; i--) {
        statusMessage.textContent = `Rate limited. Pausing for ${i} seconds...`;
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }

      statusMessage.textContent = originalMessage;
      continue;
    }
    return response;
  }
  throw new Error(
    "Failed to fetch after multiple retries due to rate limiting."
  );
}

// --- Main Batch Processing Function ---
async function getModUpdateInfoBatch(jobs, batchSize = 25) {
  // Process the entire job list as a single batch since we're already batching at the higher level
  return await processBatch(jobs);
}

async function processBatch(jobs) {
  const loader = modLoaderSelect.value;
  const gameVersion = mcVersionSelect.value;
  
  // Step 0: Check cache for complete results first
  const cachedResults = [];
  const uncachedJobs = [];
  const processedCacheKeys = new Set(); // Prevent double-counting
  
  // Pre-calculate all hashes in parallel for uploaded files and mrpack files
  const fileHashPromises = jobs
    .filter(job => job.type === "file" || job.type === "mrpack")
    .map(async job => {
      const hash = await calculateFileHash(job.data);
      return { job, hash };
    });
  
  const fileHashes = await Promise.all(fileHashPromises);
  const hashMap = new Map(fileHashes.map(fh => [fh.job, fh.hash]));
  
  for (const job of jobs) {
    let cacheKey;
    if (job.type === "file") {
      const hash = hashMap.get(job);
      if (hash) {
        cacheKey = getCacheKey(hash, loader, gameVersion, 'hash');
      }
    } else if (job.type === "mrpack") {
      // For .mrpack files, we want to look up the modpack itself as a project
      const hash = hashMap.get(job);
      if (hash) {
        // Use the hash to look up the modpack
        cacheKey = getCacheKey(hash, loader, gameVersion, 'hash');
      }
    } else if (job.type === "hash") {
      cacheKey = getCacheKey(job.data, loader, gameVersion, 'hash');
    } else if (job.type === "id") {
      cacheKey = getCacheKey(job.data, loader, gameVersion, 'id');
    }
    
    if (cacheKey && !processedCacheKeys.has(cacheKey)) {
      processedCacheKeys.add(cacheKey);
      const cachedResult = getCachedResult(cacheKey);
      if (cachedResult) {
        // Add cache indicator to result
        cachedResult.fromCache = true;
        cachedResults.push(cachedResult);
        continue;
      }
    }
    
    uncachedJobs.push(job);
  }
  
  // If all results were cached, return them immediately
  if (uncachedJobs.length === 0) {
    return cachedResults;
  }
  
  // Process uncached jobs through normal pipeline
  const freshResults = await processBatchUncached(uncachedJobs, loader, gameVersion);
  
  // Cache the fresh results
  for (const result of freshResults) {
    let cacheKey;
    if (result.hash) {
      cacheKey = getCacheKey(result.hash, loader, gameVersion, 'hash');
    } else if (result.projectId) {
      cacheKey = getCacheKey(result.projectId, loader, gameVersion, 'id');
    }
    
    if (cacheKey) {
      // Don't cache the fromCache flag
      const resultToCache = { ...result };
      delete resultToCache.fromCache;
      setCachedResult(cacheKey, resultToCache);
    }
  }
  
  // Combine cached and fresh results
  return [...cachedResults, ...freshResults];
}

async function processBatchUncached(uncachedJobs, loader, gameVersion) {
  // Step 1: Collect all hashes and project IDs
  const hashJobs = [];
  const projectIdJobs = [];
  const fileJobs = [];
  
  for (const job of uncachedJobs) {
    if (job.type === "file") {
      const hash = await calculateFileHash(job.data);
      if (hash) {
        hashJobs.push({ job, hash });
      } else {
        fileJobs.push(job);
      }
    } else if (job.type === "mrpack") {
      // For .mrpack files, we want to look up the modpack itself as a project
      const hash = await calculateFileHash(job.data);
      if (hash) {
        hashJobs.push({ job, hash });
      } else {
        fileJobs.push(job);
      }
    } else if (job.type === "hash") {
      hashJobs.push({ job, hash: job.data });
    } else if (job.type === "id") {
      projectIdJobs.push(job);
    }
  }
  
  // Step 2: Batch hash lookups
  const hashResults = await batchHashLookup(hashJobs);
  
  // Step 3: Batch project lookups
  const allProjectIds = [
    ...hashResults.map(r => r.versionData?.project_id).filter(Boolean),
    ...projectIdJobs.map(j => j.data)
  ];
  
  const projectsData = await batchProjectLookup(allProjectIds);
  
  // Step 4: Batch author lookups
  const authorData = await batchAuthorLookup(projectsData);
  
  // Step 5: Batch version lookups for compatible versions
  const versionData = await batchVersionLookup(projectsData, loader, gameVersion);
  
  // Step 6: Combine results
  return await combineResults(uncachedJobs, hashResults, projectsData, authorData, versionData);
}

// --- Batch Hash Lookup Function ---
async function batchHashLookup(hashJobs) {
  if (hashJobs.length === 0) return [];
  
  // Use the batch version_files endpoint
  const hashes = hashJobs.map(hj => hj.hash);
  
  const response = await fetchWithRetry('https://api.modrinth.com/v2/version_files', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      algorithm: "sha1",
      hashes: hashes
    })
  });
  
  if (response.ok) {
    const versionMap = await response.json();
    return hashJobs.map(hj => ({
      job: hj.job,
      hash: hj.hash,
      versionData: versionMap[hj.hash] || null
    }));
  }
  
  return hashJobs.map(hj => ({ job: hj.job, hash: hj.hash, versionData: null }));
}

// --- Batch Project Lookup Function ---
async function batchProjectLookup(projectIds) {
  if (projectIds.length === 0) return {};
  
  // Remove duplicates
  const uniqueIds = [...new Set(projectIds.filter(Boolean))];
  
  // Use batch projects endpoint
  const idsParam = JSON.stringify(uniqueIds);
  const response = await fetchWithRetry(
    `https://api.modrinth.com/v2/projects?ids=${encodeURIComponent(idsParam)}`
  );
  
  if (response.ok) {
    const projects = await response.json();
    // Convert array to map for easy lookup
    return projects.reduce((acc, project) => {
      acc[project.id] = project;
      return acc;
    }, {});
  }
  
  return {};
}

// --- Batch Author Lookup Function ---
async function batchAuthorLookup(projectsData) {
  const projects = Object.values(projectsData);
  
  // Collect team IDs and organization IDs
  const teamIds = projects.map(p => p.team).filter(Boolean);
  const orgIds = projects.map(p => p.organization).filter(Boolean);
  
  // Batch fetch teams and organizations in parallel
  const [teamsData, orgsData] = await Promise.all([
    batchTeamLookup(teamIds),
    batchOrganizationLookup(orgIds)
  ]);
  
  return { teams: teamsData, organizations: orgsData };
}

async function batchTeamLookup(teamIds) {
  if (teamIds.length === 0) return {};
  
  const uniqueIds = [...new Set(teamIds)];
  const idsParam = JSON.stringify(uniqueIds);
  
  const response = await fetchWithRetry(
    `https://api.modrinth.com/v3/teams?ids=${encodeURIComponent(idsParam)}`
  );
  
  if (response.ok) {
    const teams = await response.json();
    return teams.reduce((acc, team) => {
      acc[team[0]?.team_id] = team;
      return acc;
    }, {});
  }
  
  return {};
}

async function batchOrganizationLookup(orgIds) {
  if (orgIds.length === 0) return {};
  
  const uniqueIds = [...new Set(orgIds)];
  const idsParam = JSON.stringify(uniqueIds);
  
  const response = await fetchWithRetry(
    `https://api.modrinth.com/v3/organizations?ids=${encodeURIComponent(idsParam)}`
  );
  
  if (response.ok) {
    const orgs = await response.json();
    return orgs.reduce((acc, org) => {
      acc[org.id] = org;
      return acc;
    }, {});
  }
  
  return {};
}

// --- Batch Version Lookup Function ---
async function batchVersionLookup(projectsData, loader, gameVersion) {
      const projectIds = Object.keys(projectsData);
      if (projectIds.length === 0) return {};

      const versionPromises = projectIds.map(async (projectId) => {
        const project = projectsData[projectId];
        const isMod = project.project_type === 'mod';

        const allVersionsUrl = `https://api.modrinth.com/v2/project/${projectId}/version`;
        const response = await fetchWithRetry(allVersionsUrl);

        let allVersions = [];
        if (response.ok) {
          allVersions = await response.json();
        }

        // Filter for compatible versions based on project type
        const compatibleVersions = allVersions.filter(v => {
          const gameVersionMatch = v.game_versions.includes(gameVersion);
          return isMod ? (v.loaders.includes(loader) && gameVersionMatch) : gameVersionMatch;
        });

        // Analyze what's available for precise error messages
        const hasGameVersion = allVersions.some(v => v.game_versions.includes(gameVersion));
        // For non-mods, we can pretend the loader is always compatible to avoid wrong errors.
        const hasLoader = !isMod || allVersions.some(v => v.loaders.includes(loader));

        let compatibilityStatus = 'compatible';
        if (compatibleVersions.length === 0) {
            if (hasGameVersion && !hasLoader) {
                compatibilityStatus = 'wrong-loader';
            } else if (!hasGameVersion && hasLoader) {
                compatibilityStatus = 'wrong-version';
            } else if (!hasGameVersion && !hasLoader) {
                compatibilityStatus = 'no-versions';
            } else if (hasGameVersion && hasLoader) {
                // This case now correctly handles mods where versions for the loader and game exist, but not together.
                compatibilityStatus = 'separate-versions';
            } else {
                compatibilityStatus = 'incompatible';
            }
        }

        return {
          projectId,
          versions: compatibleVersions,
          allVersions,
          compatibilityStatus,
          hasGameVersion,
          hasLoader
        };
      });

      const results = await Promise.all(versionPromises);

      return results.reduce((acc, result) => {
        acc[result.projectId] = result;
        return acc;
      }, {});
}

// --- Results Combination Function ---
async function combineResults(jobs, hashResults, projectsData, authorData, versionData) {
  const results = [];
  
  for (const job of jobs) {
    try {
      let projectDetails = null;
      let versionDetails = null;
      let originalModInfo = {};
      
      // Find project details based on job type
      let fileHash = null; // Track hash for caching
      if (job.type === "hash" || job.type === "file" || job.type === "mrpack") {
        const hashResult = hashResults.find(hr => hr.job === job);
        if (hashResult?.versionData) {
          projectDetails = projectsData[hashResult.versionData.project_id];
          versionDetails = hashResult.versionData;
          fileHash = hashResult.hash; // Preserve hash for caching
        }
        
                 // Get original version from uploaded file if available
         if (job.type === "file" || job.type === "mrpack") {
           try {
             originalModInfo = await getModIdFromJar(job.data);
           } catch (e) {
             // Ignore errors getting mod info from JAR
             originalModInfo = {};
           }
         }
      } else if (job.type === "id") {
        projectDetails = projectsData[job.data];
      }
      
             if (!projectDetails) {
         results.push({
           status: "failure",
           title: job.type === "file" ? job.data.name : job.title,
           reason: "Mod not found on Modrinth"
         });
         continue;
       }
      
      // Get author details
      const author = getAuthorFromBatchData(projectDetails, authorData);
      
      // Get compatible versions and compatibility analysis
      const versionInfo = versionData[projectDetails.id] || { versions: [], compatibilityStatus: 'no-versions' };
      const versions = versionInfo.versions || [];
      const release = versions.find(v => v.version_type === "release");
      const beta = versions.find(v => v.version_type === "beta");
      const alpha = versions.find(v => v.version_type === "alpha");
      const latestVersion = release || beta || alpha;
      
             if (!latestVersion) {
         // Generate precise error message based on compatibility analysis
         let reason = "No compatible version found for selected loader/version.";
         const loader = modLoaderSelect.value;
         const gameVersion = mcVersionSelect.value;
         
         switch (versionInfo.compatibilityStatus) {
           case 'wrong-loader':
             reason = `Compatible with MC ${gameVersion}, but not available for ${loader.charAt(0).toUpperCase() + loader.slice(1)}.`;
             break;
           case 'wrong-version':
             reason = `Available for ${loader.charAt(0).toUpperCase() + loader.slice(1)}, but no versions found for MC ${gameVersion}.`;
             break;
           case 'no-versions':
             reason = `No versions available for MC ${gameVersion} or ${loader.charAt(0).toUpperCase() + loader.slice(1)}.`;
             break;
           case 'separate-versions':
             reason = `Has versions for both MC ${gameVersion} and ${loader.charAt(0).toUpperCase() + loader.slice(1)}, but no single version supports both.`;
             break;
           default:
             reason = "No compatible version found for selected loader/version.";
         }
         
         results.push({
           status: "warning",
           title: projectDetails.title,
           projectId: projectDetails.id,
           hash: fileHash, // Add hash for caching
           author_name: author.name,
           author_url: author.url,
           description: projectDetails.description,
           icon_url: projectDetails.icon_url,
           project_url: `https://modrinth.com/project/${projectDetails.slug}`,
           client_side: projectDetails.client_side,
           server_side: projectDetails.server_side,
           downloads: projectDetails.downloads,
           followers: projectDetails.followers,
           categories: projectDetails.categories,
           project_type: projectDetails.project_type,
           reason: reason
         });
         continue;
       }
      
             const primaryFile = latestVersion.files.find(f => f.primary);
       if (!primaryFile) {
         results.push({
           status: "warning",
           title: projectDetails.title,
           author_name: author.name,
           author_url: author.url,
           reason: "No primary file found for latest version."
         });
         continue;
       }
      
      // Compare versions if we have original mod info
      const isUpToDate = originalModInfo.version && 
        latestVersion && 
        originalModInfo.version === latestVersion.version_number;
      
      // Gather download info for .mrpack file
      // Define the folder path based on project type
      let folderPath = "mods/";
      if (projectDetails.project_type === "resourcepack") {
        folderPath = "resourcepacks/";
      } else if (projectDetails.project_type === "shader") {
        folderPath = "shaderpacks/";
      }

      const downloadInfo = {
        url: primaryFile.url,
        filename: primaryFile.filename,
        hashes: primaryFile.hashes,
        path: `${folderPath}${primaryFile.filename}`,
        fileSize: primaryFile.size,
        client_side: projectDetails.client_side,
        server_side: projectDetails.server_side,
        projectId: projectDetails.id, // Add project ID for ignore functionality
        isMrpackFile: job.type === "mrpack" || job.isMrpackFile === true // Transfer the mrpack flag
      };
      
      // Add to successful downloads if not already tracked
      if (!renderedModIds.has(projectDetails.slug)) {
        successfulDownloads.push(downloadInfo);
      }
      
              // Build success response
        results.push({
          status: "success",
          modId: projectDetails.slug,
          projectId: projectDetails.id, // Add project ID for dependency tracking
          hash: fileHash, // Add hash for caching (null for dependency lookups)
          isUpToDate: isUpToDate,
          categories: projectDetails.categories,
          title: projectDetails.title,
        author_name: author.name,
        author_url: author.url,
        description: projectDetails.description,
        icon_url: projectDetails.icon_url,
        project_url: `https://modrinth.com/project/${projectDetails.slug}`,
        client_side: projectDetails.client_side,
        server_side: projectDetails.server_side,
        followers: projectDetails.followers,
        downloads: projectDetails.downloads,
        project_type: projectDetails.project_type,
        all_versions: versions,
        dependencies: latestVersion.dependencies,
        isDependency: job.isDependencyJob === true,
        // Flag if this is the actual .mrpack file (not the extracted mods)
        isMrpackFile: job.type === "mrpack" || job.isMrpackFile === true
      });
      
    } catch (error) {
      results.push({
        status: "failure",
        title: job.type === "file" ? job.data.name : job.title,
        reason: error.message
      });
    }
  }
  
  return results;
}

function getAuthorFromBatchData(projectDetails, authorData) {
  // Check for organization first
  if (projectDetails.organization) {
    const org = authorData.organizations[projectDetails.organization];
    if (org) {
      return {
        name: org.name,
        url: `https://modrinth.com/organization/${org.slug}`
      };
    }
  }
  
  // Fall back to team owner
  const team = authorData.teams[projectDetails.team];
  if (team) {
    const owner = team.find(member => member.is_owner || member.role === "Owner");
    if (owner?.user) {
      return {
        name: owner.user.username,
        url: `https://modrinth.com/user/${owner.user.username}`
      };
    }
  }
  
  return { name: "unknown", url: "#" };
}

      // --- Get Mod ID from JAR ---
      async function getModIdFromJar(jarFile) {
  try {
    const zip = await JSZip.loadAsync(jarFile);
    const fabricFile = zip.file("fabric.mod.json");
    if (fabricFile) {
      const content = await fabricFile.async("string");
      const manifest = JSON.parse(content);
      // Also return the version property
      return {
        id: manifest.id,
        name: manifest.name,
        version: manifest.version,
      };
    }

    const forgeFile = zip.file("META-INF/mods.toml");
    if (forgeFile) {
      const content = await forgeFile.async("string");
      const manifest = toml.parse(content);
      const modInfo = manifest.mods && manifest.mods[0];
      if (modInfo) {
        // Also return the version property
        return {
          id: modInfo.modId,
          name: modInfo.displayName,
          version: modInfo.version,
        };
      }
    }
    throw new Error("Could not find a valid manifest file.");
  } catch (e) {
    throw new Error("Invalid or corrupt JAR file.");
  }
}

      // --- Setup Result Sections ---
function setupResultSections() {
  // --- SVG icons for the layout toggle button ---
  const gridIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect></svg>`;
  const listIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>`;
  const copyIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="m5 15-1 0c-1.1 0-2-.9-2-2l0-9c0-1.1.9-2 2-2l9 0c1.1 0 2 .9 2 2l0 1"></path></svg>`;
  const sortIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="7,10 12,5 17,10"></polyline><polyline points="7,14 12,19 17,14"></polyline></svg>`;
  const ignoreIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M4.93 4.93l14.14 14.14"></path></svg>`;

  resultsArea.innerHTML = `
    <div id="results-found" class="results-section">
      <!-- Header container for title and buttons -->
      <div class="results-header-container">
        <h2 id="header-found">Updates Found</h2>
        <div class="header-buttons">
          <input type="text" id="search-found" class="search-box" placeholder="Filter mods..." style="margin-right: 0.5rem;">
          <button id="ignore-found-btn" class="layout-toggle header-button" title="Toggle ignore mode">${ignoreIcon}</button>
          <div class="sort-dropdown-container">
            <button id="sort-found-btn" class="layout-toggle" title="Sort Results">${sortIcon}</button>
            <div id="sort-found-dropdown" class="sort-dropdown">
              <div class="sort-option active" data-sort="default">Default</div>
              <div class="sort-option has-submenu">
                Categories <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="category" data-filter="adventure">Adventure</div>
                  <div class="sort-option" data-sort="category" data-filter="cursed">Cursed</div>
                  <div class="sort-option" data-sort="category" data-filter="decoration">Decoration</div>
                  <div class="sort-option" data-sort="category" data-filter="economy">Economy</div>
                  <div class="sort-option" data-sort="category" data-filter="equipment">Equipment</div>
                  <div class="sort-option" data-sort="category" data-filter="food">Food</div>
                  <div class="sort-option" data-sort="category" data-filter="game-mechanics">Mechanics</div>
                  <div class="sort-option" data-sort="category" data-filter="library">Library</div>
                  <div class="sort-option" data-sort="category" data-filter="magic">Magic</div>
                  <div class="sort-option" data-sort="category" data-filter="management">Management</div>
                  <div class="sort-option" data-sort="category" data-filter="minigame">Minigame</div>
                  <div class="sort-option" data-sort="category" data-filter="mobs">Mobs</div>
                  <div class="sort-option" data-sort="category" data-filter="optimization">Optimization</div>
                  <div class="sort-option" data-sort="category" data-filter="social">Social</div>
                  <div class="sort-option" data-sort="category" data-filter="storage">Storage</div>
                  <div class="sort-option" data-sort="category" data-filter="technology">Technology</div>
                  <div class="sort-option" data-sort="category" data-filter="transportation">Transportation</div>
                  <div class="sort-option" data-sort="category" data-filter="utility">Utility</div>
                  <div class="sort-option" data-sort="category" data-filter="worldgen">Worldgen</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Name <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="name" data-direction="false">A-Z</div>
                  <div class="sort-option" data-sort="name" data-direction="true">Z-A</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Downloads <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="downloads" data-direction="false">High to Low</div>
                  <div class="sort-option" data-sort="downloads" data-direction="true">Low to High</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Followers <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="followers" data-direction="false">High to Low</div>
                  <div class="sort-option" data-sort="followers" data-direction="true">Low to High</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Last Updated <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="updated" data-direction="false">Newest First</div>
                  <div class="sort-option" data-sort="updated" data-direction="true">Oldest First</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Environments <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="clientserver" data-filter="client">Client Only</div>
                  <div class="sort-option" data-sort="clientserver" data-filter="server">Server Only</div>
                  <div class="sort-option" data-sort="clientserver" data-filter="both">Client & Server</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Channels <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="channel" data-filter="release">Release</div>
                  <div class="sort-option" data-sort="channel" data-filter="beta">Beta</div>
                  <div class="sort-option" data-sort="channel" data-filter="alpha">Alpha</div>
                </div>
              </div>
            </div>
          </div>
          <button id="copy-found-btn" class="layout-toggle" title="Copy Mod List">${copyIcon}</button>
          <button id="layout-toggle-btn" class="layout-toggle" title="Toggle Layout">${gridIcon}</button>
        </div>
      </div>
      <div class="results-list"></div>
    </div>
    <div id="results-warning" class="results-section">
      <!-- Header container for title and buttons -->
      <div class="results-header-container">
        <h2 id="header-warning">Not Compatible</h2>
        <div class="header-buttons">
          <input type="text" id="search-warning" class="search-box" placeholder="Filter mods..." style="margin-right: 0.5rem;">

          <div class="sort-dropdown-container">
            <button id="sort-warning-btn" class="layout-toggle" title="Sort Results">${sortIcon}</button>
            <div id="sort-warning-dropdown" class="sort-dropdown">
              <div class="sort-option active" data-sort="default">Default</div>
              <div class="sort-option has-submenu">
                Categories <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="category" data-filter="adventure">Adventure</div>
                  <div class="sort-option" data-sort="category" data-filter="cursed">Cursed</div>
                  <div class="sort-option" data-sort="category" data-filter="decoration">Decoration</div>
                  <div class="sort-option" data-sort="category" data-filter="economy">Economy</div>
                  <div class="sort-option" data-sort="category" data-filter="equipment">Equipment</div>
                  <div class="sort-option" data-sort="category" data-filter="food">Food</div>
                  <div class="sort-option" data-sort="category" data-filter="game-mechanics">Mechanics</div>
                  <div class="sort-option" data-sort="category" data-filter="library">Library</div>
                  <div class="sort-option" data-sort="category" data-filter="magic">Magic</div>
                  <div class="sort-option" data-sort="category" data-filter="management">Management</div>
                  <div class="sort-option" data-sort="category" data-filter="minigame">Minigame</div>
                  <div class="sort-option" data-sort="category" data-filter="mobs">Mobs</div>
                  <div class="sort-option" data-sort="category" data-filter="optimization">Optimization</div>
                  <div class="sort-option" data-sort="category" data-filter="social">Social</div>
                  <div class="sort-option" data-sort="category" data-filter="storage">Storage</div>
                  <div class="sort-option" data-sort="category" data-filter="technology">Technology</div>
                  <div class="sort-option" data-sort="category" data-filter="transportation">Transportation</div>
                  <div class="sort-option" data-sort="category" data-filter="utility">Utility</div>
                  <div class="sort-option" data-sort="category" data-filter="worldgen">Worldgen</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Name <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="name" data-direction="false">A-Z</div>
                  <div class="sort-option" data-sort="name" data-direction="true">Z-A</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Downloads <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="downloads" data-direction="false">High to Low</div>
                  <div class="sort-option" data-sort="downloads" data-direction="true">Low to High</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Followers <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="followers" data-direction="false">High to Low</div>
                  <div class="sort-option" data-sort="followers" data-direction="true">Low to High</div>
                </div>
              </div>
              <div class="sort-option has-submenu">
                Environments <span class="submenu-arrow"></span>
                <div class="sort-submenu">
                  <div class="sort-option" data-sort="clientserver" data-filter="client">Client Only</div>
                  <div class="sort-option" data-sort="clientserver" data-filter="server">Server Only</div>
                  <div class="sort-option" data-sort="clientserver" data-filter="both">Client & Server</div>
                </div>
              </div>
            </div>
          </div>
          <button id="copy-warning-btn" class="layout-toggle" title="Copy Mod List">${copyIcon}</button>
          <button id="warning-layout-toggle-btn" class="layout-toggle" title="Toggle Layout">${gridIcon}</button>
        </div>
      </div>
      <div class="results-list"></div>
    </div>
    <div id="results-failure" class="results-section">
      <h2 id="header-failure">Could Not Find Mod</h2>
      <div class="results-list"></div>
    </div>
  `;

  // --- Logic for the found section layout toggle button ---
  const layoutToggleBtn = document.getElementById("layout-toggle-btn");
  const foundResultsList = document.querySelector("#results-found .results-list");

  // Function to set the layout based on stored preference or default
  function setLayout() {
    const currentLayout = localStorage.getItem("mod-layout") || "list";
    if (currentLayout === "grid") {
      foundResultsList.classList.add("grid-view");
      layoutToggleBtn.innerHTML = listIcon;
    } else {
      foundResultsList.classList.remove("grid-view");
      layoutToggleBtn.innerHTML = gridIcon;
    }
  }

  layoutToggleBtn.addEventListener("click", () => {
    foundResultsList.classList.toggle("grid-view");
    // Save the new preference to localStorage
    if (foundResultsList.classList.contains("grid-view")) {
      localStorage.setItem("mod-layout", "grid");
      layoutToggleBtn.innerHTML = listIcon; // Show list icon
    } else {
      localStorage.setItem("mod-layout", "list");
      layoutToggleBtn.innerHTML = gridIcon; // Show grid icon
    }
  });

  // Set the initial layout when the page loads
  setLayout();

  // --- Logic for the warning section layout toggle button ---
  const warningLayoutToggleBtn = document.getElementById("warning-layout-toggle-btn");
  const warningResultsList = document.querySelector("#results-warning .results-list");

  // Function to set the warning layout based on stored preference or default
  function setWarningLayout() {
    const currentLayout = localStorage.getItem("warning-layout") || "list";
    if (currentLayout === "grid") {
      warningResultsList.classList.add("grid-view");
      warningLayoutToggleBtn.innerHTML = listIcon;
      // Auto-expand reason sections in grid view
      expandAllReasons();
    } else {
      warningResultsList.classList.remove("grid-view");
      warningLayoutToggleBtn.innerHTML = gridIcon;
      // Auto-hide reason sections in list view
      hideAllReasons();
    }
  }

  // Function to expand all reason sections in warning cards
  function expandAllReasons() {
    const warningCards = document.querySelectorAll("#results-warning .result-card");
    warningCards.forEach(card => {
      const reasonContent = card.querySelector(".changelog-content");
      if (reasonContent) {
        reasonContent.classList.add("visible");
      }
    });
  }

  // Function to hide all reason sections in warning cards
  function hideAllReasons() {
    const warningCards = document.querySelectorAll("#results-warning .result-card");
    warningCards.forEach(card => {
      const reasonContent = card.querySelector(".changelog-content");
      if (reasonContent) {
        reasonContent.classList.remove("visible");
      }
    });
  }

  warningLayoutToggleBtn.addEventListener("click", () => {
    warningResultsList.classList.toggle("grid-view");
    // Save the new preference to localStorage
    if (warningResultsList.classList.contains("grid-view")) {
      localStorage.setItem("warning-layout", "grid");
      warningLayoutToggleBtn.innerHTML = listIcon; // Show list icon
      // Auto-expand reason sections in grid view
      expandAllReasons();
    } else {
      localStorage.setItem("warning-layout", "list");
      warningLayoutToggleBtn.innerHTML = gridIcon; // Show grid icon
      // Auto-hide reason sections in list view
      hideAllReasons();
    }
  });

  // Set the initial warning layout when the page loads
  setWarningLayout();

// --- Ignore Mode Functionality (Global Scope) ---
let isIgnoreMode = false;
let ignoredMods = new Set();
// Make ignoredMods globally accessible
window.ignoredMods = ignoredMods;

// Function to handle download or ignore button clicks
window.handleDownloadOrIgnore = function(event, projectId) {
  if (isIgnoreMode) {
    // In ignore mode, always toggle ignore status, never download
    event.preventDefault();
    event.stopPropagation();
    window.toggleIgnoreStatus(projectId);
    return false;
  } else if (!ignoredMods.has(projectId)) {
    // In normal mode for non-ignored mods: allow normal download
    // Don't prevent default - let the normal link behavior work
    return true;
  } else {
    // Ignored mods in normal mode do nothing (button is disabled)
    event.preventDefault();
    event.stopPropagation();
    return false;
  }
};

// Function to toggle ignore status of a specific mod
window.toggleIgnoreStatus = function(projectId) {
  const card = document.querySelector(`[data-project-id="${projectId}"]`);
  const btn = card.querySelector('.download-link');
  
  if (!card || !btn) {
    console.error('Could not find card or button for project ID:', projectId);
    return;
  }
  
  if (ignoredMods.has(projectId)) {
    // Un-ignore
    ignoredMods.delete(projectId);
    card.classList.remove('ignored');
    btn.textContent = 'Ignore';
    btn.classList.remove('ignored');
  } else {
    // Ignore
    ignoredMods.add(projectId);
    card.classList.add('ignored');
    btn.textContent = 'Un-ignore';
    btn.classList.add('ignored');
  }
  
  window.updateDownloadCounters();
};

// Function to update download counters excluding ignored mods
window.updateDownloadCounters = function() {
  try {
    // Check if successfulDownloads exists and is accessible
    if (typeof successfulDownloads !== 'undefined' && successfulDownloads) {
      const nonIgnoredDownloads = successfulDownloads.filter(dl => {
        // Exclude both ignored mods and .mrpack files from bulk downloads
        const isIgnored = window.ignoredMods && window.ignoredMods.has(dl.projectId);
        const isMrpackFile = dl.isMrpackFile === true;
        return !isIgnored && !isMrpackFile;
      });
      
      // Update Download All button text more reliably
      const downloadAllBtn = document.querySelector('.action-button');
      if (downloadAllBtn) {
        const svgContent = downloadAllBtn.querySelector('svg');
        const svgHTML = svgContent ? svgContent.outerHTML : '';
        downloadAllBtn.innerHTML = `Download All (${nonIgnoredDownloads.length})\n          ${svgHTML}`;
      }
      
      // Update all size info elements
      const sizeInfoElements = document.querySelectorAll('.download-size-info');
      if (sizeInfoElements.length > 0) {
        if (nonIgnoredDownloads.length > 0) {
          const totalSizeBytes = nonIgnoredDownloads.reduce(
            (sum, file) => sum + (file.fileSize || 0),
            0
          );
          const formattedSize = formatBytes(totalSizeBytes);
          
          // Update Download All and Download ZIP size info (same size)
          sizeInfoElements.forEach((sizeInfo, index) => {
            if (index < 2) { // First two are Download All and Download ZIP
              sizeInfo.textContent = formattedSize;
            }
            // The third one (.mrpack) keeps its original tiny size
          });
        } else {
          // If no mods to download, show 0 bytes
          sizeInfoElements.forEach((sizeInfo, index) => {
            if (index < 2) { // First two are Download All and Download ZIP
              sizeInfo.textContent = '0 Bytes';
            }
          });
        }
      }
      

    } else {

    }
  } catch (error) {
    console.error('Error updating download counters:', error);
  }
};

// Function to toggle ignore mode for the found section
function toggleIgnoreMode() {
    isIgnoreMode = !isIgnoreMode;
    const ignoreModeBtn = document.getElementById('ignore-found-btn');
    const sectionElement = document.getElementById('results-found');
    
    if (isIgnoreMode) {
      ignoreModeBtn.classList.add('ignore-mode-active');
      sectionElement.classList.add('ignore-mode-active');
    } else {
      ignoreModeBtn.classList.remove('ignore-mode-active');
      sectionElement.classList.remove('ignore-mode-active');
    }
    
    // Transform all download buttons in the found section
    const downloadLinks = document.querySelectorAll('#results-found .download-link');
    downloadLinks.forEach(btn => {
      const projectId = btn.dataset.projectId;
      const isIgnored = ignoredMods.has(projectId);
      
      if (isIgnoreMode) {
        // In ignore mode: remove download functionality
        btn.classList.add('ignore-mode');
        btn.classList.remove('ignored-state');
        btn.textContent = isIgnored ? 'Un-ignore' : 'Ignore';
        if (isIgnored) btn.classList.add('ignored');
        
        // Store original href and remove it to prevent accidental downloads
        if (!btn.dataset.originalHref && btn.href !== '#') {
          btn.dataset.originalHref = btn.href;
        }
        btn.href = '#';
        btn.removeAttribute('download');
      } else {
        // In normal mode: restore download functionality
        btn.classList.remove('ignore-mode', 'ignored');
        if (isIgnored) {
          btn.classList.add('ignored-state');
          btn.textContent = 'Ignored';
          btn.href = '#';
          btn.removeAttribute('download');
        } else {
          btn.classList.remove('ignored-state');
          btn.textContent = 'Download';
          
          // Restore original href if it exists
          if (btn.dataset.originalHref) {
            btn.href = btn.dataset.originalHref;
          }
        }
      }
    });
  }



  // Add event listener for ignore mode button
  const ignoreFoundBtn = document.getElementById('ignore-found-btn');

  if (ignoreFoundBtn) {
    ignoreFoundBtn.addEventListener('click', toggleIgnoreMode);
  }

  // --- Copy to clipboard functionality ---
  const copyFoundBtn = document.getElementById("copy-found-btn");
  const copyWarningBtn = document.getElementById("copy-warning-btn");

  copyFoundBtn.addEventListener("click", () => {
    const foundCards = document.querySelectorAll("#results-found .result-card:not(.ignored)");
    const modNames = Array.from(foundCards).map(card => {
      const titleLink = card.querySelector(".mod-title a");
      return titleLink ? titleLink.textContent : "";
    }).filter(name => name).join('\n');
    copyToClipboard(modNames, copyFoundBtn, "Updates");
  });

  copyWarningBtn.addEventListener("click", () => {
    const warningCards = document.querySelectorAll("#results-warning .result-card:not(.ignored)");
    const modNames = Array.from(warningCards).map(card => {
      const titleLink = card.querySelector(".mod-title a");
      return titleLink ? titleLink.textContent : "";
    }).filter(name => name).join('\n');
    copyToClipboard(modNames, copyWarningBtn, "Incompatible mods");
  });

  // --- Search functionality ---
  const searchFoundInput = document.getElementById("search-found");
  const searchWarningInput = document.getElementById("search-warning");

  // Function to filter cards based on search term
  function filterCards(searchTerm, sectionSelector) {
    const cards = document.querySelectorAll(`${sectionSelector} .result-card`);
    const lowerSearchTerm = searchTerm.toLowerCase();
    
    cards.forEach(card => {
      const titleElement = card.querySelector(".mod-title a");
      const title = titleElement ? titleElement.textContent.toLowerCase() : "";
      
      if (title.includes(lowerSearchTerm)) {
        card.style.display = "";
      } else {
        card.style.display = "none";
      }
    });
  }

  // Add event listeners for search inputs
  searchFoundInput.addEventListener("input", (e) => {
    filterCards(e.target.value, "#results-found");
  });

  searchWarningInput.addEventListener("input", (e) => {
    filterCards(e.target.value, "#results-warning");
  });

  // --- Sort functionality ---
  const sortFoundBtn = document.getElementById("sort-found-btn");
  const sortFoundDropdown = document.getElementById("sort-found-dropdown");
  const sortWarningBtn = document.getElementById("sort-warning-btn");
  const sortWarningDropdown = document.getElementById("sort-warning-dropdown");

  let currentFoundSort = 'default';
  let currentWarningSort = 'default';
  let foundSortDirection = {}; // Track sort direction for each sort type
  let warningSortDirection = {}; // Track sort direction for each sort type

  // Toggle dropdown visibility
  function toggleSortDropdown(dropdown, otherDropdown) {
    dropdown.classList.toggle('show');
    otherDropdown.classList.remove('show'); // Close other dropdown
  }

  // Close dropdowns when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.sort-dropdown-container')) {
      sortFoundDropdown.classList.remove('show');
      sortWarningDropdown.classList.remove('show');
    }
  });

  // Prevent dropdown from closing when hovering over submenus
  [sortFoundDropdown, sortWarningDropdown].forEach(dropdown => {
    dropdown.addEventListener('mouseleave', (e) => {
      // Small delay to allow moving to submenu
      setTimeout(() => {
        if (!dropdown.matches(':hover') && !dropdown.querySelector('.sort-submenu:hover')) {
          // Could add additional logic here if needed
        }
      }, 100);
    });
  });

  // Sort button click handlers
  sortFoundBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleSortDropdown(sortFoundDropdown, sortWarningDropdown);
  });

  sortWarningBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleSortDropdown(sortWarningDropdown, sortFoundDropdown);
  });

  // Sort option selection handlers
  sortFoundDropdown.addEventListener('click', (e) => {
    if (e.target.classList.contains('sort-option') && e.target.dataset.sort) {
      const sortType = e.target.dataset.sort;
      
      // First clear any existing filters when switching options
      clearFilters('#results-found');
      
      if (sortType === 'default') {
        // Default order - just clear everything and show all cards
        selectSortOption(sortFoundDropdown, 'default');
        currentFoundSort = 'default';
        clearFilters('#results-found');
        restoreOriginalOrder('#results-found');
      } else if (e.target.dataset.filter) {
        // This is a filter option
        const filterValue = e.target.dataset.filter;
        selectSortOption(sortFoundDropdown, sortType, false, e.target.textContent, filterValue);
        currentFoundSort = sortType;
        applyFiltering('#results-found', sortType, filterValue);
      } else if (e.target.dataset.direction !== undefined) {
        // This is a sorting option
        const isReversed = e.target.dataset.direction === 'true';
        foundSortDirection[sortType] = isReversed;
        selectSortOption(sortFoundDropdown, sortType, isReversed, e.target.textContent);
        currentFoundSort = sortType;
        applySorting('#results-found', sortType, isReversed);
      }
      
      sortFoundDropdown.classList.remove('show');
    }
  });

  sortWarningDropdown.addEventListener('click', (e) => {
    if (e.target.classList.contains('sort-option') && e.target.dataset.sort) {
      const sortType = e.target.dataset.sort;
      
      // First clear any existing filters when switching options
      clearFilters('#results-warning');
      
      if (sortType === 'default') {
        // Default order - just clear everything and show all cards
        selectSortOption(sortWarningDropdown, 'default');
        currentWarningSort = 'default';
        clearFilters('#results-warning');
        restoreOriginalOrder('#results-warning');
      } else if (e.target.dataset.filter) {
        // This is a filter option
        const filterValue = e.target.dataset.filter;
        selectSortOption(sortWarningDropdown, sortType, false, e.target.textContent, filterValue);
        currentWarningSort = sortType;
        applyFiltering('#results-warning', sortType, filterValue);
      } else if (e.target.dataset.direction !== undefined) {
        // This is a sorting option
        const isReversed = e.target.dataset.direction === 'true';
        warningSortDirection[sortType] = isReversed;
        selectSortOption(sortWarningDropdown, sortType, isReversed, e.target.textContent);
        currentWarningSort = sortType;
        applySorting('#results-warning', sortType, isReversed);
      }
      
      sortWarningDropdown.classList.remove('show');
    }
  });

  // Update active sort option
  function selectSortOption(dropdown, sortType, isReversed = false, optionText = '', filterValue = '') {
    // Remove active class from all options
    dropdown.querySelectorAll('.sort-option').forEach(option => {
      option.classList.remove('active');
    });
    
    if (sortType === 'default') {
      const defaultOption = dropdown.querySelector('[data-sort="default"]');
      if (defaultOption) defaultOption.classList.add('active');
    } else if (filterValue) {
      // Find the specific filter option that was clicked
      const targetOption = dropdown.querySelector(`[data-sort="${sortType}"][data-filter="${filterValue}"]`);
      if (targetOption) targetOption.classList.add('active');
      
      // Also highlight the root option (the parent menu item)
      const rootOption = targetOption.closest('.sort-option.has-submenu');
      if (rootOption) rootOption.classList.add('active');
    } else {
      // Find the specific sorting option that was clicked
      const targetOption = dropdown.querySelector(`[data-sort="${sortType}"][data-direction="${isReversed}"]`);
      if (targetOption) targetOption.classList.add('active');
      
      // Also highlight the root option (the parent menu item)
      const rootOption = targetOption.closest('.sort-option.has-submenu');
      if (rootOption) rootOption.classList.add('active');
    }
  }

  // Apply sorting to a section
  function applySorting(sectionSelector, sortType, isReversed = false) {
    const section = document.querySelector(sectionSelector);
    const resultsList = section.querySelector('.results-list');
    const cards = Array.from(resultsList.querySelectorAll('.result-card'));
    
    // Add original order index to each card if not already present
    cards.forEach((card, index) => {
      if (!card.dataset.originalIndex) {
        card.dataset.originalIndex = index;
      }
    });
    
    if (sortType === 'default') {
      // Sort by original index
      cards.sort((a, b) => {
        return parseInt(a.dataset.originalIndex) - parseInt(b.dataset.originalIndex);
      });
    } else {
      // Sort cards based on type
      cards.sort((a, b) => {
        switch (sortType) {
          case 'name':
            const nameA = a.querySelector('.mod-title a')?.textContent.toLowerCase() || '';
            const nameB = b.querySelector('.mod-title a')?.textContent.toLowerCase() || '';
            return nameA.localeCompare(nameB);
            
                  case 'downloads':
          const downloadsA = extractDownloads(a);
          const downloadsB = extractDownloads(b);
          return downloadsB - downloadsA; // High to low
          
        case 'followers':
          const followersA = extractFollowers(a);
          const followersB = extractFollowers(b);
          return followersB - followersA; // High to low
          
                case 'updated':
          const dateA = extractDate(a);
          const dateB = extractDate(b);
          return dateB - dateA; // Newest first
          
        case 'clientserver':
          const clientServerA = extractClientServer(a);
          const clientServerB = extractClientServer(b);
          return clientServerA.localeCompare(clientServerB);
          
        case 'channel':
          const channelA = extractChannel(a);
          const channelB = extractChannel(b);
          return channelA.localeCompare(channelB);
              
        default:
          return 0;
        }
      });
    }

    // Reverse the order if requested
    if (isReversed && sortType !== 'default') {
      cards.reverse();
    }

    // Re-append cards in sorted order (this preserves all event listeners)
    cards.forEach(card => resultsList.appendChild(card));
  }

  // Apply filtering to a section
  function applyFiltering(sectionSelector, filterType, filterValue) {
    const section = document.querySelector(sectionSelector);
    const resultsList = section.querySelector('.results-list');
    const cards = Array.from(resultsList.querySelectorAll('.result-card'));

    cards.forEach(card => {
      let shouldShow = true;

      if (filterType === 'clientserver') {
        const cardSupport = extractClientServer(card);
        shouldShow = cardSupport === filterValue;
      } else if (filterType === 'channel') {
        const cardChannel = extractChannel(card);
        shouldShow = cardChannel === filterValue;
      } else if (filterType === 'category') {
        const cardCategories = extractCategories(card);
        shouldShow = cardCategories.includes(filterValue);
      }

      if (shouldShow) {
        card.style.display = '';
      } else {
        card.style.display = 'none';
      }
    });
  }

  // Clear all filters for a section
  function clearFilters(sectionSelector) {
    const section = document.querySelector(sectionSelector);
    const cards = section.querySelectorAll('.result-card');
    cards.forEach(card => {
      card.style.display = '';
    });
  }

  // Restore original order for a section
  function restoreOriginalOrder(sectionSelector) {
    const section = document.querySelector(sectionSelector);
    const resultsList = section.querySelector('.results-list');
    const cards = Array.from(resultsList.querySelectorAll('.result-card'));

    // Sort by original index
    cards.sort((a, b) => {
      const indexA = parseInt(a.dataset.originalIndex) || 0;
      const indexB = parseInt(b.dataset.originalIndex) || 0;
      return indexA - indexB;
    });

    // Re-append cards in original order
    cards.forEach(card => resultsList.appendChild(card));
  }

  // Helper functions to extract data from cards
  function extractDownloads(card) {
    // Look for the downloads meta item - it has a download icon (polyline with points="7 10 12 15 17 10")
    const metaItems = card.querySelectorAll('.mod-meta-item');
    for (let item of metaItems) {
      const svg = item.querySelector('svg polyline[points="7 10 12 15 17 10"]');
      if (svg) {
        // This is the downloads item
        const span = item.querySelector('span');
        if (span) {
          const text = span.textContent.trim();
          const num = parseFloat(text);
          if (text.includes('M')) return num * 1000000;
          if (text.includes('K')) return num * 1000;
          if (text.includes('B')) return num * 1000000000;
          return num;
        }
      }
    }
    return 0;
  }

  function extractFollowers(card) {
    // Look for the followers meta item - it has a heart icon
    const metaItems = card.querySelectorAll('.mod-meta-item');
    for (let item of metaItems) {
      const svg = item.querySelector('svg path[d*="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"]');
      if (svg) {
        // This is the followers item
        const span = item.querySelector('span');
        if (span) {
          const text = span.textContent.trim();
          const num = parseFloat(text);
          if (text.includes('M')) return num * 1000000;
          if (text.includes('K')) return num * 1000;
          if (text.includes('B')) return num * 1000000000;
          return num;
        }
      }
    }
    return 0;
  }

  function extractDate(card) {
    // Look for the date span that gets populated by formatTimeAgo
    const dateSpan = card.querySelector('.mod-meta-date');
    if (dateSpan && dateSpan.textContent) {
      const dateText = dateSpan.textContent.trim();
      
      // Parse relative time formats like "2d ago", "3h ago", "1mo ago"
      const match = dateText.match(/(\d+)(s|m|h|d|mo|y)\s+ago/i);
      if (match) {
        const amount = parseInt(match[1]);
        const unit = match[2].toLowerCase();
        const now = Date.now();
        
        switch (unit) {
          case 's': return now - (amount * 1000);
          case 'm': return now - (amount * 60 * 1000);
          case 'h': return now - (amount * 60 * 60 * 1000);
          case 'd': return now - (amount * 24 * 60 * 60 * 1000);
          case 'mo': return now - (amount * 30 * 24 * 60 * 60 * 1000);
          case 'y': return now - (amount * 365 * 24 * 60 * 60 * 1000);
          default: return now;
        }
      }
    }
    
    // If no date found, return current time (will appear as same age)
    return Date.now();
  }

  function extractClientServer(card) {
    // Look for client/server support in mod-meta-item spans
    const metaItems = card.querySelectorAll('.mod-meta-item span');
    
    for (let span of metaItems) {
      const text = span.textContent.trim().toLowerCase();
      if (text === 'client & server') return 'both';
      if (text === 'client-side') return 'client';
      if (text === 'server-side') return 'server';
    }
    
    return 'none';
  }

  function extractChannel(card) {
    // Look for visible channel links - these are shown based on the selected version type
    const alphaLink = card.querySelector('.channel-link.alpha');
    const betaLink = card.querySelector('.channel-link.beta');
    const releaseLink = card.querySelector('.channel-link.release');
    
    // Check which channel link is visible (has display: inline)
    if (alphaLink && alphaLink.style.display === 'inline') return 'alpha';
    if (betaLink && betaLink.style.display === 'inline') return 'beta';
    if (releaseLink && releaseLink.style.display === 'inline') return 'release';
    
    return 'release'; // Default to release if no visible channel found
  }

  function extractCategories(card) {
    // Look for the category tooltip which contains all categories for this mod
    const categoryTooltip = card.querySelector('.category-tooltip');
    if (categoryTooltip && categoryTooltip.textContent) {
      const categoriesText = categoryTooltip.textContent.trim();
      // Split by comma and clean up each category
      const categories = categoriesText.split(',').map(cat => {
        const trimmed = cat.trim().toLowerCase();
        // Convert display names back to filter values
        const categoryMap = {
          'adventure': 'adventure',
          'cursed': 'cursed', 
          'decoration': 'decoration',
          'economy': 'economy',
          'equipment': 'equipment',
          'food': 'food',
          'game mechanics': 'game-mechanics',
          'library': 'library',
          'magic': 'magic',
          'management': 'management',
          'minigame': 'minigame',
          'mobs': 'mobs',
          'optimization': 'optimization',
          'social': 'social',
          'storage': 'storage',
          'technology': 'technology',
          'transportation': 'transportation',
          'utility': 'utility',
          'world generation': 'worldgen'
        };
        return categoryMap[trimmed] || trimmed;
      });
      return categories;
    }
    return [];
  }



  // Reset sort states when results are cleared
  window.resetSortStates = function() {
    currentFoundSort = 'default';
    currentWarningSort = 'default';
    foundSortDirection = {};
    warningSortDirection = {};
    
    // Reset dropdown selections
    if (sortFoundDropdown) {
      selectSortOption(sortFoundDropdown, 'default');
    }
    if (sortWarningDropdown) {
      selectSortOption(sortWarningDropdown, 'default');
    }
    
    // Clear any applied filters by showing all cards
    document.querySelectorAll('.result-card').forEach(card => {
      card.style.display = '';
    });
  };
}

// Helper function to copy text to clipboard and show feedback
async function copyToClipboard(text, button, listType) {
  const originalHTML = button.innerHTML;
  const successIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
  const errorIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
  
  try {
    await navigator.clipboard.writeText(text);
    button.innerHTML = successIcon;
    button.style.color = "var(--success-color)";
    setTimeout(() => {
      button.innerHTML = originalHTML;
      button.style.color = "";
    }, 1500);
  } catch (err) {
    console.error('Failed to copy text: ', err);
    button.innerHTML = errorIcon;
    button.style.color = "var(--error-color)";
    setTimeout(() => {
      button.innerHTML = originalHTML;
      button.style.color = "";
    }, 1500);
  }
}

      // --- Helper to update section headers with counts ---
      function updateSectionHeader(type, count) {
        const headerId = `header-${type}`; // e.g., 'header-found'
        const headerElement = document.getElementById(headerId);
        if (!headerElement) return; // Safety check

        let baseText = "";
        switch (type) {
          case "found":
            baseText = "Updates Found";
            break;
          case "warning":
            baseText = "Not Compatible";
            break;
          case "failure":
            baseText = "Could Not Find Mod";
            break;
        }

        // Only show the count if it's greater than zero
        if (count > 0) {
          headerElement.textContent = `${baseText} (${count})`;
        }
      }

      function renderSingleResult(result) {
        let sectionId, card, countType;

        switch (result.status) {
          case "success":
            sectionId = "results-found";
            card = createSuccessCard(result);
            countType = "found";
            break;
          case "warning":
            sectionId = "results-warning";
            card = createWarningCard(result);
            countType = "warning";
            break;
          case "failure":
            sectionId = "results-failure";
            card = createFailureCard(result);
            countType = "failure";
            break;
        }

        // Increment the appropriate counter
        if (countType) {
          sectionCounts[countType]++;
          updateSectionHeader(countType, sectionCounts[countType]);
        }

        // First, check for duplicates.
        if (result.status === "success" && renderedModIds.has(result.modId)) {
          // If it's a duplicate, we do nothing else.
        } else {
          // If it's NOT a duplicate (or it's a warning/failure), then we render it.
          const section = document.getElementById(sectionId);
          if (section) {
            section.querySelector(".results-list").appendChild(card);
            section.classList.add("visible");
          }
          // And if it was a new success, we add it to our tracking set.
          if (result.status === "success") {
            renderedModIds.add(result.modId);
          }
        }
      }

      // --- Update Dependency Chain Tooltip ---
      function updateDependencyChainTooltip(projectId, dependencyName) {
        // Find all cards that are waiting for this dependency name
        const resultCards = document.querySelectorAll('.result-card');
        
        resultCards.forEach(card => {
          // Check if this card has dependencies that include the projectId
          const titleLink = card.querySelector('.mod-title a');
          if (!titleLink) return;
          
          const modTitle = titleLink.textContent;
          let cardProjectId = null;
          
          // Find this card's projectId
          for (const [id, name] of modIdToNameMap.entries()) {
            if (name === modTitle) {
              cardProjectId = id;
              break;
            }
          }
          
          if (!cardProjectId || !reverseDependencyMap.has(cardProjectId)) {
            return;
          }
          
          const dependencyIds = reverseDependencyMap.get(cardProjectId);
          
          // Check if this card depends on the projectId we just processed
          if (dependencyIds.includes(projectId)) {
            const chainTooltip = card.querySelector('.dependency-chain-tooltip');
            if (chainTooltip) {
              // Update the tooltip with the actual dependency names
              const dependencyNames = [];
              for (const depId of dependencyIds) {
                const modName = modIdToNameMap.get(depId);
                dependencyNames.push(modName || depId);
              }
              chainTooltip.textContent = `Depends on: ${dependencyNames.join(", ")}`;
            }
          }
        });
      }

      // --- Finalize Results UI ---
      function finalizeResultsUI() {
        // Check for the empty state first
        if (
          sectionCounts.found === 0 &&
          sectionCounts.warning === 0 &&
          sectionCounts.failure === 0
        ) {
    resultsArea.innerHTML = `
      <div class="results-section visible" style="text-align: center;">
        <h2>No Mods Found</h2>
        <p style="line-height: 1.6;">
          We couldn't find any mods matching your selected criteria. This can happen if the mods you uploaded don't have versions available for the selected Minecraft version and loader.
        </p>
      </div>
    `;
    return;
        }
        // Show the "Clear Results" button if there are any results
        clearResultsButton.style.display = "inline-flex";

        const foundSection = document.getElementById("results-found");
        if (foundSection && successfulDownloads.length > 0) {
          // Calculate non-ignored downloads and exclude .mrpack files from bulk downloads
          const nonIgnoredDownloads = successfulDownloads.filter(dl => {
            // Exclude both ignored mods and .mrpack files from bulk downloads
            const isIgnored = window.ignoredMods && window.ignoredMods.has(dl.projectId);
            const isMrpackFile = dl.isMrpackFile === true;
            return !isIgnored && !isMrpackFile;
          });
          
          const actionsContainer = document.createElement("div");
          actionsContainer.className = "results-actions";

          // --- Create a dedicated container for the "Download All" button and its size ---
          const downloadAllGroup = document.createElement("div");
          downloadAllGroup.className = "download-button-group";

          // Create and add the "Download All" button to its group
          const downloadAllBtn = document.createElement("button");
          downloadAllBtn.className = "action-button";
          downloadAllBtn.innerHTML = `Download All (${nonIgnoredDownloads.length})
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>`;
          downloadAllBtn.onclick = () => {
            // Filter out ignored mods and .mrpack files using the global ignoredMods set
            const downloadsToProcess = successfulDownloads.filter(dl => {
              const isIgnored = window.ignoredMods && window.ignoredMods.has(dl.projectId);
              const isMrpackFile = dl.isMrpackFile === true;
              return !isIgnored && !isMrpackFile;
            });
            
            if (downloadsToProcess.length === 0) {
              alert('No mods to download. All mods are currently ignored.');
              return;
            }
            
            let i = 0;
            function downloadNext() {
              if (i < downloadsToProcess.length) {
                const dl = downloadsToProcess[i];
                const link = document.createElement("a");
                link.href = dl.url;
                link.setAttribute("download", dl.filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                i++;
                setTimeout(downloadNext, 300);
              }
            }
            downloadNext();
          };
          downloadAllGroup.appendChild(downloadAllBtn);

          // Create a dedicated container for the "Download .zip" button and its size
          const downloadZipGroup = document.createElement("div");
          downloadZipGroup.className = "download-button-group";

          // Create the .zip button
          const downloadZipBtn = document.createElement("button");
          downloadZipBtn.className = "action-button";
          downloadZipBtn.innerHTML = `Download .zip
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path>
            <polyline points="8 16 12 20 16 16"></polyline>
            <path d="M12 12v8"></path>
          </svg>`;
          downloadZipBtn.onclick = () => downloadAllAsZip();
          downloadZipGroup.appendChild(downloadZipBtn);

          // Create a dedicated container for the "Download as .mrpack" button and its size
          const downloadPackGroup = document.createElement("div");
          downloadPackGroup.className = "download-button-group";

          // Create the .mrpack button
          const downloadPackBtn = document.createElement("button");
          downloadPackBtn.className = "action-button";
          downloadPackBtn.innerHTML = `Download as .mrpack`;
          downloadPackBtn.onclick = () => createModpack();
          downloadPackGroup.appendChild(downloadPackBtn);

          // Add all the groups to the main actions container
          actionsContainer.appendChild(downloadAllGroup);
          actionsContainer.appendChild(downloadZipGroup);
          actionsContainer.appendChild(downloadPackGroup);
          foundSection.appendChild(actionsContainer);

          // --- Calculate and add the size info to all button groups ---
          try {
            const totalSizeBytes = nonIgnoredDownloads.reduce(
              (sum, file) => sum + (file.fileSize || 0),
              0
            );

            if (totalSizeBytes > 0) {
              const formattedSize = formatBytes(totalSizeBytes);
              
              // Add size info to Download All button (total mod files)
              const sizeInfoAll = document.createElement("p");
              sizeInfoAll.className = "download-size-info";
              sizeInfoAll.textContent = formattedSize;
              downloadAllGroup.appendChild(sizeInfoAll);
              
              // Add size info to Download .zip button (same as Download All)
              const sizeInfoZip = document.createElement("p");
              sizeInfoZip.className = "download-size-info";
              sizeInfoZip.textContent = formattedSize;
              downloadZipGroup.appendChild(sizeInfoZip);
            }
            
            // Calculate .mrpack size (just the manifest JSON, very small)
            const loaderNameMap = {
              fabric: "fabric-loader",
              forge: "forge",
              quilt: "quilt-loader",
              neoforge: "neoforge",
            };
            const selectedLoader = modLoaderSelect.value;
            const officialLoaderName = loaderNameMap[selectedLoader] || selectedLoader;
            
            const manifest = {
              formatVersion: 1,
              game: "minecraft",
              versionId: "temp",
              name: "temp",
              version: "1.0.0",
              dependencies: {
                minecraft: mcVersionSelect.value,
                [officialLoaderName]: "*",
              },
              files: nonIgnoredDownloads.map((dl) => ({
                path: dl.path,
                files: successfulDownloads.map(file => ({
                  path: file.path,
                  hashes: file.hashes,
                  env: {
                    client: file.client_side,
                    server: file.server_side,
                  },
                  downloads: [file.url],
                  fileSize: file.fileSize,
                })),
                env: {}
              })),
            };
            
            // Calculate actual manifest size
            const manifestJson = JSON.stringify(manifest, null, 2);
            const manifestBytes = new Blob([manifestJson]).size;
            
            // Add size info to Download .mrpack button (tiny manifest file only)
            const sizeInfoPack = document.createElement("p");
            sizeInfoPack.className = "download-size-info";
            sizeInfoPack.textContent = formatBytes(manifestBytes);
            downloadPackGroup.appendChild(sizeInfoPack);
            
          } catch (error) {
            console.error("Could not calculate total download size:", error);
          }
        }

        // Hide empty sections
        if (sectionCounts.warning === 0) {
          const warningSection = document.getElementById("results-warning");
          if (warningSection) warningSection.style.display = "none";
        }
        if (sectionCounts.failure === 0) {
          const failureSection = document.getElementById("results-failure");
          if (failureSection) failureSection.style.display = "none";
        }
      }

      // Check if all sections are empty after processing
      if (
          sectionCounts.found === 0 &&
          sectionCounts.warning === 0 &&
          sectionCounts.failure === 0
        ) {
          resultsArea.innerHTML = `
            <div class="results-section visible">
              <h2>Search Complete</h2>
              <p>We couldn't find any information for the mods in your list on Modrinth. They may be from another source like CurseForge, or the files may be corrupt.</p>
            </div>
          `;
      }

      // --- Update Dependency Chain on Existing Card ---
function updateDependencyChainOnCard(projectId) {
  const card = document.querySelector(`.result-card[data-project-id="${projectId}"]`);
  if (!card || !reverseDependencyMap.has(projectId)) return;

  const modTitleDiv = card.querySelector('.mod-title');
  let chainContainer = card.querySelector('.dependency-chain-tooltip-container');

  const dependencyIds = reverseDependencyMap.get(projectId);
  const dependencyNames = dependencyIds.map(id => modIdToNameMap.get(id) || 'Loading...');
  const tooltipText = `Depends on: ${dependencyNames.join(", ")}`;

  if (chainContainer) {
    // If the icon already exists, just update its tooltip
    const tooltip = chainContainer.querySelector('.dependency-chain-tooltip');
    if (tooltip) {
      tooltip.textContent = tooltipText;
    }
  } else {
    // If the icon doesn't exist, create and add it
    chainContainer = document.createElement('span');
    chainContainer.className = 'dependency-chain-tooltip-container';
    chainContainer.innerHTML = `
      <svg class="dependency-chain-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
      </svg>
      <span class="dependency-chain-tooltip">${tooltipText}</span>
    `;
    
    const firstTag = modTitleDiv.querySelector('.mod-title-tag, .dependency-tooltip-container');
    if (firstTag) {
      modTitleDiv.insertBefore(chainContainer, firstTag);
    } else {
      modTitleDiv.appendChild(chainContainer);
    }
  }
}

// --- Create Success Card ---
function createSuccessCard(mod) {
  const card = document.createElement("div");
  let cardClasses = "result-card";
  
  // Determine the appropriate border color class
  if (mod.isDependency) {
    cardClasses += " dependency";
  } else if (mod.isUpToDate) {
    cardClasses += " already-up-to-date";
  } else {
    cardClasses += " success";
  }
  
  card.className = cardClasses;
  card.setAttribute('data-project-id', mod.projectId);

  const clientServerInfo = getClientServerSupport(
    mod.client_side,
    mod.server_side
  );
  const versionOptions = mod.all_versions
    .map((v) => {
      const type = v.version_type.charAt(0).toUpperCase();
      return `<option value="${v.id}">${v.version_number} [${type}]</option>`;
    })
    .join("");

  // This HTML now contains TWO sets of channel links.
  card.innerHTML = `
    <div class="result-card-main">
      <a href="${
        mod.project_url
      }" target="_blank" rel="noopener noreferrer" class="mod-icon-link">
        <img src="${
          mod.icon_url || DEFAULT_MOD_ICON
        }" alt="${
    mod.title
  } icon" class="mod-icon" onerror="this.src=DEFAULT_MOD_ICON">
      </a>
      <div class="mod-details">
        <div class="mod-title">
          <a href="${
            mod.project_url
          }" target="_blank" rel="noopener noreferrer">${mod.title}</a>

          ${
            mod.isDependency
              ? `<span class="dependency-tooltip-container">
                   <span class="mod-title-tag dependency-tag">(Dependency)</span>
                   <span class="dependency-tooltip">Required by: ${(() => {
                     // Look up which mod requires this dependency
                     return dependencyMap.get(mod.projectId) || 'Unknown';
                   })()}</span>
                 </span>`
              : ""
          }
        </div>
        <div class="mod-author">
          by <a href="${
            mod.author_url
          }" target="_blank" rel="noopener noreferrer">${mod.author_name}</a>
        </div>
        <div class="mod-description">${mod.description}</div>
        <div class="mod-meta">
          <div class="mod-meta-item meta-tooltip-container">
            ${clientServerInfo.svg}
            <span>${clientServerInfo.text}</span>
            <span class="meta-tooltip">Supported Environments</span>
          </div>
          <div class="mod-meta-item meta-tooltip-container">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
            <span class="mod-meta-date"></span>
            <span class="meta-tooltip">Last Updated</span>
          </div>
          <div class="mod-meta-item meta-tooltip-container">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
            <span>${formatDownloads(mod.downloads)}</span>
            <span class="meta-tooltip">Total Downloads</span>
          </div>
          <div class="mod-meta-item meta-tooltip-container">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
            </svg>
            <span>${formatDownloads(mod.followers)}</span>
            <span class="meta-tooltip">Followers</span>
          </div>
          <div class="mod-meta-item category-tooltip-container" style="display: none;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2H2v10l9.29 9.29a1 1 0 0 0 1.42 0l8-8a1 1 0 0 0 0-1.42L12 2z"></path>
              <path d="M7 7h.01"></path>
            </svg>
            <span class="category-tooltip"></span>
          </div>
          <div class="mod-meta-item changelog-toggle">Changelog</div>
          <div class="mod-meta-item list-view-channels">
            <a href="#" target="_blank" rel="noopener noreferrer" class="channel-link release" style="display: none;">Release</a>
            <a href="#" target="_blank" rel="noopener noreferrer" class="channel-link beta" style="display: none;">Beta</a>
            <a href="#" target="_blank" rel="noopener noreferrer" class="channel-link alpha" style="display: none;">Alpha</a>
          </div>
        </div>
      </div>
      <div class="mod-actions">
        <select class="version-select">${versionOptions}</select>
        <div class="grid-bottom-line">
          <div class="grid-view-channels">
            <a href="#" target="_blank" rel="noopener noreferrer" class="channel-link release" style="display: none;">Release</a>
            <a href="#" target="_blank" rel="noopener noreferrer" class="channel-link beta" style="display: none;">Beta</a>
            <a href="#" target="_blank" rel="noopener noreferrer" class="channel-link alpha" style="display: none;">Alpha</a>
          </div>
          <a href="#" class="download-link" data-project-id="${mod.projectId}">Download</a>
        </div>
      </div>
    </div>
    <div class="changelog-content"></div>`;

  // Get references to ALL the elements we need to update
  const versionSelect = card.querySelector(".version-select");
  const downloadLink = card.querySelector(".download-link");
  const dateSpan = card.querySelector(".mod-meta-date");
  const changelogToggle = card.querySelector(".changelog-toggle");
  const changelogContent = card.querySelector(".changelog-content");

  // Get references to BOTH sets of links
  const listLinks = {
    release: card.querySelector(".list-view-channels .release"),
    beta: card.querySelector(".list-view-channels .beta"),
    alpha: card.querySelector(".list-view-channels .alpha"),
  };
  const gridLinks = {
    release: card.querySelector(".grid-view-channels .release"),
    beta: card.querySelector(".grid-view-channels .beta"),
    alpha: card.querySelector(".grid-view-channels .alpha"),
  };

  // --- Update Dynamic Content ---
  function updateDynamicContent() {
    const selectedVersionId = versionSelect.value;
    const selectedVersion = mod.all_versions.find(
      (v) => v.id === selectedVersionId
    );
    if (!selectedVersion) return;

    const primaryFile = selectedVersion.files.find((f) => f.primary);

    // Remove previous version from downloads list if it exists
    const existingDownloadIndex = successfulDownloads.findIndex(dl => dl.projectId === mod.projectId);
    if (existingDownloadIndex > -1) {
        successfulDownloads.splice(existingDownloadIndex, 1);
    }

    if (primaryFile) {
      downloadLink.href = primaryFile.url;
      downloadLink.setAttribute("download", primaryFile.filename);

      // Define the folder path based on project type
      let folderPath = "mods/";
      if (mod.project_type === "resourcepack") {
        folderPath = "resourcepacks/";
      } else if (mod.project_type === "shader") {
        folderPath = "shaderpacks/";
      }

      // --- Add new version to the list for bulk downloads ---
      successfulDownloads.push({
          projectId: mod.projectId,
          url: primaryFile.url,
          filename: primaryFile.filename,
          projectType: mod.project_type,
          fileSize: primaryFile.size,
          isMrpackFile: mod.isMrpackFile,
          // --- Data for .mrpack manifest ---
          path: `${folderPath}${primaryFile.filename}`,
          hashes: primaryFile.hashes,
          client_side: mod.client_side,
          server_side: mod.server_side,
      });
    }
    dateSpan.textContent = formatTimeAgo(selectedVersion.date_published);
    changelogContent.innerHTML = marked.parse(
      selectedVersion.changelog || "No changelog provided for this version."
    );

    // Hide all links in both sets first
    Object.values(listLinks).forEach((link) => (link.style.display = "none"));
    Object.values(gridLinks).forEach((link) => (link.style.display = "none"));

    const versionUrl = `${mod.project_url}/version/${selectedVersion.version_number}`;
    const versionType = selectedVersion.version_type; // 'release', 'beta', or 'alpha'

    // Update the correct link in BOTH sets
    if (listLinks[versionType] && gridLinks[versionType]) {
      listLinks[versionType].href = versionUrl;
      listLinks[versionType].style.display = "inline";
      gridLinks[versionType].href = versionUrl;
      gridLinks[versionType].style.display = "inline";
    }
  }

  versionSelect.addEventListener("change", updateDynamicContent);
  changelogToggle.addEventListener("click", () => {
    changelogContent.classList.toggle("visible");
  });

  updateDynamicContent();

  // --- Add ignore mode event handler to download link ---
  downloadLink.addEventListener('click', (event) => {
    window.handleDownloadOrIgnore(event, mod.projectId);
  });

  // --- Add Dependency Chain Icon if needed ---
  if (reverseDependencyMap.has(mod.projectId)) {
    const dependencyIds = reverseDependencyMap.get(mod.projectId);
    const dependencyNames = [];
    
    // Get dependency names (some might still be "Loading...")
    for (const depId of dependencyIds) {
      const modName = modIdToNameMap.get(depId);
      dependencyNames.push(modName || "Loading...");
    }
    
    const initialTooltipText = `Depends on: ${dependencyNames.join(", ")}`;
    
    // Create and add the chain icon
    const modTitleDiv = card.querySelector('.mod-title');
    const chainContainer = document.createElement('span');
    chainContainer.className = 'dependency-chain-tooltip-container';
    chainContainer.innerHTML = `
      <svg class="dependency-chain-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
      </svg>
      <span class="dependency-chain-tooltip">${initialTooltipText}</span>
    `;
    
    // Insert before any existing tags
    const firstTag = modTitleDiv.querySelector('.mod-title-tag, .dependency-tooltip-container');
    if (firstTag) {
      modTitleDiv.insertBefore(chainContainer, firstTag);
    } else {
      modTitleDiv.appendChild(chainContainer);
    }
  }

// --- Add project_type tag if available ---
if (mod.project_type) {
  const titleElement = card.querySelector(".mod-title");
  const tag = document.createElement("span");
  tag.className = "mod-title-tag";
  tag.textContent = `(${mod.project_type.charAt(0).toUpperCase() + mod.project_type.slice(1)})`;
  
  // Insert after any chain icon but before other tags
  const chainContainer = titleElement.querySelector('.dependency-chain-tooltip-container');
  if (chainContainer) {
    // Insert after chain icon
    if (chainContainer.nextSibling) {
      titleElement.insertBefore(tag, chainContainer.nextSibling);
    } else {
      titleElement.appendChild(tag);
    }
  } else {
    // No chain icon, insert as first tag
    const firstTag = titleElement.querySelector('.mod-title-tag, .dependency-tooltip-container');
    if (firstTag) {
      titleElement.insertBefore(tag, firstTag);
    } else {
      titleElement.appendChild(tag);
    }
  }
}

// --- Handle the "Already Up-to-Date" state ---
if (mod.isUpToDate) {
  const titleElement = card.querySelector(".mod-title");
  const tag = document.createElement("span");
  tag.className = "mod-title-tag"; // Use the new shared class
  tag.textContent = "(Already Up-to-Date)";
  titleElement.appendChild(tag);
}

// --- Populate Category Tooltip ---
if (mod.categories && mod.categories.length > 0) {
  const categoryContainer = card.querySelector(".category-tooltip-container");
  const categoryTooltip = card.querySelector(".category-tooltip");

  // This helper function turns a slug like "world-gen" into "World Gen"
  function formatCategoryName(slug) {
    return slug
      .split("-")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");
  }

  // We map over the array of string slugs and format each one
  const formattedCategories = mod.categories.map(formatCategoryName);
  categoryTooltip.textContent = formattedCategories.join(", ");

  // Now that it's populated, make the icon visible
  categoryContainer.style.display = "flex";
}

// --- Add Cache Indicator if from cache ---
if (mod.fromCache) {
  const modTitleDiv = card.querySelector('.mod-title');
  const cacheContainer = document.createElement('span');
  cacheContainer.className = 'cache-indicator-container';
  cacheContainer.innerHTML = `
    <svg class="cache-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
    </svg>
    <span class="cache-tooltip">Loaded from cache</span>
  `;
  
  // Insert after any existing icons but before tags
  const firstTag = modTitleDiv.querySelector('.mod-title-tag, .dependency-tooltip-container');
  if (firstTag) {
    modTitleDiv.insertBefore(cacheContainer, firstTag);
  } else {
    modTitleDiv.appendChild(cacheContainer);
  }
}

return card;
}

// --- Create Warning Card ---
function createWarningCard(mod) {
  const card = document.createElement("div");
  // We keep the 'warning' class for the yellow border
  card.className = "result-card warning";
  card.setAttribute('data-project-id', mod.projectId);
  const clientServerInfo = getClientServerSupport(
    mod.client_side,
    mod.server_side
  );

  card.innerHTML = `
    <div class="result-card-main">
      <a href="${mod.project_url}" target="_blank" rel="noopener noreferrer" class="mod-icon-link">
        <img src="${mod.icon_url || DEFAULT_MOD_ICON}" alt="${mod.title} icon" class="mod-icon" onerror="this.src=DEFAULT_MOD_ICON">
      </a>
      <div class="mod-details">
        <div class="mod-title">
          <a href="${mod.project_url}" target="_blank" rel="noopener noreferrer">${mod.title}</a>
        </div>
        <div class="mod-author">
          by <a href="${mod.author_url}" target="_blank" rel="noopener noreferrer">${mod.author_name}</a>
        </div>
        <div class="mod-description">${mod.description}</div>
        <div class="mod-meta">
          <div class="mod-meta-item meta-tooltip-container">
            ${clientServerInfo.svg}
            <span>${clientServerInfo.text}</span>
            <span class="meta-tooltip">Supported Environments</span>
          </div>
          <div class="mod-meta-item meta-tooltip-container">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
            <span>${formatDownloads(mod.downloads)}</span>
            <span class="meta-tooltip">Total Downloads</span>
          </div>
          <div class="mod-meta-item meta-tooltip-container">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
            </svg>
            <span>${formatDownloads(mod.followers)}</span>
            <span class="meta-tooltip">Followers</span>
          </div>
          <div class="mod-meta-item category-tooltip-container" style="display: none;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2H2v10l9.29 9.29a1 1 0 0 0 1.42 0l8-8a1 1 0 0 0 0-1.42L12 2z"></path>
              <path d="M7 7h.01"></path>
            </svg>
            <span class="category-tooltip"></span>
          </div>
          <div class="mod-meta-item changelog-toggle" style="color: var(--warning-color); font-weight: bold;">Reason</div>
        </div>
      </div>

    </div>
    <div class="changelog-content"></div>`;

  // Get references to the elements we need to update
  const reasonToggle = card.querySelector(".changelog-toggle");
  const reasonContent = card.querySelector(".changelog-content");

  // Set up the reason toggle functionality
  reasonToggle.addEventListener("click", () => {
    reasonContent.classList.toggle("visible");
  });

  // Set the reason content (but keep it hidden initially)
  reasonContent.innerHTML = `<p style="color: var(--warning-color); font-weight: bold; margin: 0;">${mod.reason}</p>`;

  // --- Add project_type tag if available ---
  if (mod.project_type) {
    const titleElement = card.querySelector(".mod-title");
    const tag = document.createElement("span");
    tag.className = "mod-title-tag";
    tag.textContent = `(${mod.project_type.charAt(0).toUpperCase() + mod.project_type.slice(1)})`;
    titleElement.appendChild(tag);
  }

  // --- Populate Category Tooltip ---
  if (mod.categories && mod.categories.length > 0) {
    const categoryContainer = card.querySelector(".category-tooltip-container");
    const categoryTooltip = card.querySelector(".category-tooltip");

    // This helper function turns a slug like "world-gen" into "World Gen"
    function formatCategoryName(slug) {
      return slug
        .split("-")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    }

    // We map over the array of string slugs and format each one
    const formattedCategories = mod.categories.map(formatCategoryName);
    categoryTooltip.textContent = formattedCategories.join(", ");

    // Now that it's populated, make the icon visible
    categoryContainer.style.display = "flex";
  }

  // --- Add Cache Indicator if from cache ---
  if (mod.fromCache) {
    const modTitleDiv = card.querySelector('.mod-title');
    const cacheContainer = document.createElement('span');
    cacheContainer.className = 'cache-indicator-container';
    cacheContainer.innerHTML = `
      <svg class="cache-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
      </svg>
      <span class="cache-tooltip">Loaded from cache</span>
    `;
    
    // Insert after any existing icons but before tags
    const firstTag = modTitleDiv.querySelector('.mod-title-tag, .dependency-tooltip-container');
    if (firstTag) {
      modTitleDiv.insertBefore(cacheContainer, firstTag);
    } else {
      modTitleDiv.appendChild(cacheContainer);
    }
  }

  return card;
}

// --- Create Failure Card ---
function createFailureCard(mod) {
        const card = document.createElement("div");
        card.className = "result-card failure";
        card.innerHTML = `
          <div class="mod-details">
            <div class="mod-title">${mod.title}</div>
            <div class="mod-description">${mod.reason}</div>
          </div>`;
        return card;
      }

// --- Helper Functions ---



      // --- File Hash Calculation with Caching ---
      const fileHashCache = new Map();
      
      async function calculateFileHash(file) {
        // Create a cache key based on file name, size, and last modified
        const cacheKey = `${file.name}-${file.size}-${file.lastModified}`;
        
        // Check if we already calculated this hash
        if (fileHashCache.has(cacheKey)) {
          return fileHashCache.get(cacheKey);
        }
        
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const binary = event.target.result;
              const wordArray = CryptoJS.lib.WordArray.create(binary);
              const hash = CryptoJS.SHA1(wordArray).toString(CryptoJS.enc.Hex);
              
              // Cache the result
              fileHashCache.set(cacheKey, hash);
              resolve(hash);
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = (error) => reject(error);
          reader.readAsArrayBuffer(file);
        });
      }

      // --- Get Client/Server Support ---
      function getClientServerSupport(client, server) {
        const both =
          '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><path d="M9 2v20"></path></svg>';
        const clientIcon =
          '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2"></rect><path d="M8 21h8"></path><path d="M12 17v4"></path></svg>';
        const serverIcon =
          '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2"></rect><rect x="2" y="14" width="20" height="8" rx="2"></rect><path d="M6 6h.01"></path><path d="M6 18h.01"></path></svg>';

        // Both sides are required
        if (client === "required" && server === "required") {
          return { text: "Client & Server", svg: both };
        }
        // Client is required, server is optional/unsupported
        else if (client === "required" && (server === "optional" || server === "unsupported")) {
          return { text: "Client-side", svg: clientIcon };
        }
        // Server is required, client is optional/unsupported  
        else if (server === "required" && (client === "optional" || client === "unsupported")) {
          return { text: "Server-side", svg: serverIcon };
        }
        // Both are optional (rare case, but treat as both supported)
        else if (client === "optional" && server === "optional") {
          return { text: "Client & Server", svg: both };
        }
        // Client is optional, server is unsupported
        else if (client === "optional" && server === "unsupported") {
          return { text: "Client-side", svg: clientIcon };
        }
        // Server is optional, client is unsupported
        else if (server === "optional" && client === "unsupported") {
          return { text: "Server-side", svg: serverIcon };
        }
        
        return { text: "Unknown", svg: "" };
      }

      // --- Format Downloads ---
      function formatDownloads(num) {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
        if (num >= 1000) return (num / 1000).toFixed(1) + "K";
        return num;
      }

      // --- Format Time Ago ---
      function formatTimeAgo(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const seconds = Math.round((now - date) / 1000);
        const minutes = Math.round(seconds / 60);
        const hours = Math.round(minutes / 60);
        const days = Math.round(hours / 24);
        const months = Math.round(days / 30.44);
        const years = Math.round(days / 365.25);
        if (seconds < 60) return `${seconds}s ago`;
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        if (days < 30) return `${days}d ago`;
        if (months < 12) return `${months}mo ago`;
        return `${years}y ago`;
      }

      // --- Download All as ZIP ---
      async function downloadAllAsZip() {
        const zip = new JSZip();

        const downloadsToProcess = successfulDownloads.filter(dl => {
          const isIgnored = window.ignoredMods && window.ignoredMods.has(dl.projectId);
          const isMrpackFile = dl.isMrpackFile === true;
          return !isIgnored && !isMrpackFile;
        });

        if (downloadsToProcess.length === 0) {
          showCustomAlert('No files to download. All items are currently ignored or not downloadable.', 'notice');
          return;
        }

        const filename = "MC-Mod-Updater.zip";
        const zipButton = Array.from(document.querySelectorAll('.action-button')).find(btn => btn.textContent.includes('Download .zip'));
        const originalText = zipButton.innerHTML;

        try {
          zipButton.innerHTML = 'Creating ZIP...';
          zipButton.disabled = true;

          const folderMap = {
            'mod': 'mods',
            'resourcepack': 'resourcepacks',
            'shader': 'shaderpacks'
          };

          for (let i = 0; i < downloadsToProcess.length; i++) {
            const dl = downloadsToProcess[i];
            zipButton.innerHTML = `Adding ${i + 1}/${downloadsToProcess.length}...`;

            try {
              const response = await fetch(dl.url);
              if (response.ok) {
                const blob = await response.blob();
                const folderName = folderMap[dl.projectType] || 'mods'; // Default to 'mods'
                zip.file(`${folderName}/${dl.filename}`, blob);
              } else {
                console.warn(`Failed to download ${dl.filename}`, response.status, response.statusText);
              }
            } catch (error) {
              console.warn(`Error downloading ${dl.filename}:`, error);
            }
          }

          zipButton.innerHTML = 'Generating ZIP...';
          const content = await zip.generateAsync({ type: "blob" });

          const link = document.createElement("a");
          link.href = URL.createObjectURL(content);
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

        } catch (error) {
          console.error("Error creating ZIP:", error);
          showCustomAlert("Error creating ZIP file. Please check the console for details.", 'error');
        } finally {
          if (zipButton) {
            zipButton.innerHTML = originalText;
            zipButton.disabled = false;
          }
        }
      } // --- Create Modpack ---
      function createModpack() {
        // Get custom modpack name and version from user
        const packName = prompt("Enter modpack name:", "My Awesome Pack");
        if (packName === null) return; // User cancelled
        
        const packVersion = prompt("Enter modpack version:", "1.0.0");
        if (packVersion === null) return; // User cancelled
        
        // Clean the pack name for filename (remove invalid characters, keep spaces)
        const cleanPackName = packName.replace(/[<>:"/\\|?*]/g, "-");
        const filename = `${cleanPackName}-v${packVersion}.mrpack`;
        
        const loaderNameMap = {
          fabric: "fabric-loader",
          forge: "forge",
          quilt: "quilt-loader",
          neoforge: "neoforge",
        };

        const selectedLoader = modLoaderSelect.value;
        const officialLoaderName = loaderNameMap[selectedLoader] || selectedLoader;

        // Filter out ignored mods and .mrpack files using the global ignoredMods set
        const filteredDownloads = successfulDownloads.filter(dl => {
          const isIgnored = window.ignoredMods && window.ignoredMods.has(dl.projectId);
          const isMrpackFile = dl.isMrpackFile === true;
          return !isIgnored && !isMrpackFile;
        });

        
        if (filteredDownloads.length === 0) {
          alert('No mods to include in modpack. All mods are currently ignored.');
          return;
        }

        const manifest = {
          formatVersion: 1,
          game: "minecraft",
          versionId: `${cleanPackName.toLowerCase().replace(/\s+/g, "-")}-${packVersion}`,
          name: packName,
          version: packVersion,
          dependencies: {
            minecraft: mcVersionSelect.value,
            [officialLoaderName]: "*",
          },
          files: filteredDownloads.map(dl => ({
            path: dl.path,
            hashes: dl.hashes,
            env: {
              client: dl.client_side,
              server: dl.server_side,
            },
            downloads: [dl.url],
            fileSize: dl.fileSize,
          })),
        };

        const zip = new JSZip();
        zip.file("modrinth.index.json", JSON.stringify(manifest, null, 2));
        zip.folder("overrides");

        zip.generateAsync({ type: "blob" }).then(function (content) {
          const link = document.createElement("a");
          link.href = URL.createObjectURL(content);
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
      }

      function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return "0 Bytes";

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
      }

      // --- Session-Based Mod Caching System ---
      const MOD_CACHE_KEY = 'mcModUpdaterCache';
      const CACHE_VERSION = '1.0';
      const CACHE_EXPIRY_HOURS = 2; // Short session-based expiry
      const MAX_CACHE_ENTRIES = 500; // Reasonable limit
      
      let cacheStats = {
        hits: 0,
        misses: 0,
        stores: 0
      };

      // Initialize cache on page load
      function initializeCache() {
        try {
          // Clear any existing cache on page load to ensure fresh sessions
          sessionStorage.removeItem(MOD_CACHE_KEY);
          cleanupExpiredCache();
        } catch (error) {
          console.warn('Cache initialization failed, clearing cache:', error);
          clearCache();
        }
      }

      // Generate cache key for a mod lookup
      function getCacheKey(identifier, loader, gameVersion, type = 'file') {
        return `${type}:${identifier}:${loader}:${gameVersion}`;
      }

      // Get cached result if valid
      function getCachedResult(cacheKey) {
        try {
          const cache = getCache();
          const entry = cache.entries[cacheKey];
          
          if (!entry) {
            cacheStats.misses++;
            return null;
          }

          // Check if entry is expired
          const now = Date.now();
          const expiry = CACHE_EXPIRY_HOURS * 60 * 60 * 1000;
          if (now - entry.timestamp > expiry) {
            // Remove expired entry
            delete cache.entries[cacheKey];
            saveCache(cache);
            cacheStats.misses++;
            return null;
          }

          cacheStats.hits++;
          return entry.result;
        } catch (error) {
          console.warn('Cache read error:', error);
          cacheStats.misses++;
          return null;
        }
      }

      // Store result in cache
      function setCachedResult(cacheKey, result) {
        try {
          const cache = getCache();
          
          // Check cache size limit
          const entries = Object.keys(cache.entries);
          if (entries.length >= MAX_CACHE_ENTRIES) {
            // Remove oldest entries (simple LRU)
            const sortedEntries = entries
              .map(key => ({ key, timestamp: cache.entries[key].timestamp }))
              .sort((a, b) => a.timestamp - b.timestamp);
            
            // Remove oldest 20% of entries
            const toRemove = Math.floor(entries.length * 0.2);
            for (let i = 0; i < toRemove; i++) {
              delete cache.entries[sortedEntries[i].key];
            }
          }

          // Store new entry
          cache.entries[cacheKey] = {
            timestamp: Date.now(),
            result: result
          };
          
          saveCache(cache);
          cacheStats.stores++;
        } catch (error) {
          console.warn('Cache write error:', error);
        }
      }

      // Get cache from sessionStorage (clears on browser refresh)
      function getCache() {
        try {
          const cached = sessionStorage.getItem(MOD_CACHE_KEY);
          if (!cached) {
            return createEmptyCache();
          }
          
          const cache = JSON.parse(cached);
          if (cache.version !== CACHE_VERSION) {
            console.log('Cache version mismatch, clearing cache');
            return createEmptyCache();
          }
          
          return cache;
        } catch (error) {
          console.warn('Cache parse error:', error);
          return createEmptyCache();
        }
      }

      // Save cache to sessionStorage (clears on browser refresh)
      function saveCache(cache) {
        try {
          cache.metadata.lastUpdated = Date.now();
          cache.metadata.totalEntries = Object.keys(cache.entries).length;
          sessionStorage.setItem(MOD_CACHE_KEY, JSON.stringify(cache));
        } catch (error) {
          if (error.name === 'QuotaExceededError') {
            console.warn('sessionStorage quota exceeded, clearing cache');
            clearCache();
          } else {
            console.warn('Cache save error:', error);
          }
        }
      }

      // Create empty cache structure
      function createEmptyCache() {
        return {
          version: CACHE_VERSION,
          entries: {},
          metadata: {
            created: Date.now(),
            lastUpdated: Date.now(),
            totalEntries: 0
          }
        };
      }

      // Clean up expired cache entries
      function cleanupExpiredCache() {
        const cache = getCache();
        const now = Date.now();
        const expiry = CACHE_EXPIRY_HOURS * 60 * 60 * 1000;
        let removedCount = 0;

        for (const [key, entry] of Object.entries(cache.entries)) {
          if (now - entry.timestamp > expiry) {
            delete cache.entries[key];
            removedCount++;
          }
        }

        if (removedCount > 0) {
          saveCache(cache);
        }
      }

      // Clear entire cache
      function clearCache() {
        try {
          sessionStorage.removeItem(MOD_CACHE_KEY);
          cacheStats = { hits: 0, misses: 0, stores: 0 };
        } catch (error) {
          console.warn('Cache clear error:', error);
        }
      }

      // Get cache statistics
      function getCacheStats() {
        const cache = getCache();
        const totalRequests = cacheStats.hits + cacheStats.misses;
        const hitRate = totalRequests > 0 ? (cacheStats.hits / totalRequests * 100).toFixed(1) : 0;
        
        return {
          ...cacheStats,
          totalRequests,
          hitRate: `${hitRate}%`,
          cacheSize: cache.metadata.totalEntries,
          cacheAge: cache.metadata.created ? Math.round((Date.now() - cache.metadata.created) / 1000 / 60) : 0
        };
      }

      // Initialize cache when page loads
      document.addEventListener('DOMContentLoaded', () => {
        // Clear the in-memory file hash cache on page load
        fileHashCache.clear();
        initializeCache();
      });
    </script>
  </body>
</html>